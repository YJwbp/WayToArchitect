## Zygote与SystemServer

Android系统相对于Linux内核而言，也是一个应用程序而已，因此也在init.rc中被声明，然后Linux内核启动后，能够接着启动Android内核。



![image-20200430161101513](https://tva1.sinaimg.cn/large/007S8ZIlly1gebv01nzkmj30qu0jygs3.jpg)



系统中第一个Dalvik虚拟机程序叫做Zygote，接下来所有的进程都是由它创建

Zygote进程主要包括2个模块：

* Socket服务端：用于接收启动新进程的命令
* Framework共享类、共享资源：Zygote进程会装载一些共享类、资源，其他进程就不再需要加载了

Zygote进程对应的具体程序是app_process，存在于system/bin目录下，启动该程序的指令是在init.rc中配置的。

Zygote孵化出的第一个进程叫做SystemServer，其对应的具体程序也是app_process



SystemServer创建了一个Socket客户端，由Ams管理，之后新进程启动消息流程如下：

> SystemServer进程中的Ams > Socket客户端 >> Zygote进程中的Socket服务端



## Zygote的启动

### 1、在init.rc中配置Zygote的启动参数

init.rc存在于设备的根目录下： /init.rc

```bash
//语法：service service_name 可执行程序的路径 可执行程序自身所需的参数列表
service zygote /system/bin/app_ process -Xzygote /system/bin --zygote --start-system-server

socket zygote stream 666
onrestart write /sys/android_ power/ request_ state wake
onrestart write /sys/power/state on
onrestart restart medi a
onrestart restart netd

```

命令解析：

1. service：告诉操作系统将zygote程序加入到系统服务中
2. **zygote：**名称，其实可以任意
3. -Xzygote：虚拟机启动所需参数，
4. /system/bin ：虚拟机程序路径，注意区分上面可执行程序路径
5. **--zygote**：指明`ZygoteInit`类作为虚拟机执行入口，否则没有该参数需要指明入口类名
6. **--start-system-server**：告知ZygoteInit启动完成后，孵化第一个进程：`SystemServer`
7. onrestart：指定服务重启后所触发的操作



### 2、启动Socket服务端口

zygote服务从app_ process启动后，会启动一个Dalvik虚拟机，而虚拟机执行的第一个Java类是ZygoteInit.java

1. 流程从ZygoteInit的main()函数开始
   1. 启动一个Socket服务端口



### 3、加载preload_classes

创建完Socket服务端后，还不能立即孵化新进程，需要加载共享类、资源。

1. 预装的类列表是在`framework.jar`中的一个文本文件列表，名称为`preload-classes`, 

   该列表的原始定义在frameworks/base/preload-classes 文本文件中，

   而该文件又是通过frameworks/base/tool/preload/WritePreloadedClassFile.java类生成的。

   在Android源码编译的时候，会最终把preload-lasses文件打包到frameworkjar中

2. 有了这个列表后，ZygoteInit 中通过调用`preloadClasses()`完成装载这些类。

   * 装载的方法很简单，就是读取preload-classes列表中的每一行， 因为每一行代表了 一个具体的类，然后调用Class.forName()装载目标类

   

### 4、加载preload_resources

1. preload- resources是在frameworks/base/core/res/res/values/arrays.xml中被定义的

   包含两类资源:

   * drawable资源：preloadResources > preloadDrawables()加载
   * color资源：preloadResources > preloadColorStateLists()加载

2. 加载的原理：把这些资源读出来放到一个全局变量中（都是Resources：mResources），只要该类对象不被销毁，这些全局变量就会一直保存。



新版本还会有其他共享资源的加载：preloadSharedLibraries()：`libandroid.so` 、`libcompiler_rt.so` 和 `libjnigraphics.so`



### 5、使用fork启动新进程

>  fork是Linux系统的一个系统调用，其作用是复制当前进程，产生一个新的进程。
>
> 新进程将拥有和原始进程完全相同的进程信息，除了进程id不同。

为什么复制而不是创建？——进程共享大量程序，复制可以节省大量共享内存



fork()函数的返回值与普通函数调用完全不同

* 当返回值大于0时，代表的是父进程；
* 当等于0时，代表的是被复制的进程。

换句话说，父进程和子进程的代码都在该C文件中，只是不同的进程执行不同的代码，而进程是靠fork()的返回值进行区分的。



```java
// 1、ZygoteInit.java 的如下方法，复制一个新的进程
pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs. debugFlags, rlimits);

// 2、根据返回的pid不同，有不同的操作
if(pid==0){
  // 表示在子进程运行
  handleChildProc()
}else{
  handleParentProc()
}

// 3、而handleChildProc关键代码：
//当zygote复制新进程时，已经创建了一个Socket服务端，而这个服务端是不应该被新进程使用的，否则系统中会有多个进程接收Socket客户端的命令。因此，新进程被创建好后，首先需要在新进程中关闭该Socket 服务端
closeSocket();
ZygoteInit.closeServerSocket();

// 4、接着从指定Class文件的main()函数处开始执行:
	ZygoteInit.invokeStaticMain(cloader, className, mainArgs );

// 5、至此，新进程就完全脱离了zygote进程的孵化过程，成为一个真正的应用进程。
```



## SystemServer进程的启动

ZygoteInit.java : main() >> startSystemServer()，该函数有3个关键点：

1. 定义一个参数数组，指明进程启动后加载的第一个Java类：com.android. server.SystemServer
2. 孵化新进程：Zygote.forkSystemServer，类似于孵化其他进程的forkAndSpecialize
3. 关闭Socket服务端，执行SystemServer的main函数

`PS：`其实流程跟上面普通进程复制差不多，只是函数名不同



### 1、启动各种服务线程

AmS、PMS、WmS等都是以一个**线程**的形式存在于SystemServer进程中。

```java
//SystemServer伪代码
public static void main(){
  init1();// native 调用，处理DVM相关初始化
  init2();// 启动各种服务
}

private static final void init2(){
  Slog.i(TAG, "Entered the Android system server!");
	Thread thr = newServerThread();// 内部开始真正启动各种服务
	thr.setName("android.server.ServerThread");
	thr.start();
}
```

##### 启动模式

* 模式一：直接使用构造函数构造一个服务。由于大多数服务都对应一个线程，因此，在构造
  函数内部就会创建一个线程并自动运行。

* 模式二：服务类会提供一个getInstance()方法.通过该方法获取该服务对象，这样的好处是保
  证系统中仅包含一个该服务对象。

* 模式三：从服务类的main()函数中开始执行。

  



![image-20200501023038382](https://tva1.sinaimg.cn/large/007S8ZIlly1geccwp8nk1j314g0ew79b.jpg)



#####启动完成

当AmS执行完systemReady后，会相继启动相关联服务的systemReady()函数，完成整体初始化。



###2、启动第一个Activity

1. AmS的systemReady函数内部的最后一段代码则发出了启动任务队列中最上面一个Activity的消息:

   ```java
   mMainStack.resumeTopActivityLocked(null);
   ```

2. 由于系统刚启动时，mMainStack 队列中并没有任何Activity 对象，因此, ActivityStack 类中将调用
   startHomeActivityLocked函数

3. startHomeActivityLocked发出一个category字段包含CATEGORY_HOME的Intent

4. 启动声明响应该Intent的Home程序(用户可选择)

   



### Android系统启动流程是什么？

（提示：init进程 -> Zygote进程 –> SystemServer进程 –> 各种系统服务 –> 应用进程）

Android系统启动的核心流程如下：

- 1、**启动电源以及系统启动**：当电源按下时引导芯片从预定义的地方（固化在ROM）开始执行，加载引导程序BootLoader到RAM，然后执行。
- 2、**引导程序BootLoader**：BootLoader是在Android系统开始运行前的一个小程序，主要用于把系统OS拉起来并运行。
- 3、**Linux内核启动**：当内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。当其完成系统设置时，会先在系统文件中寻找init.rc文件，并启动init进程。
- 4、**init进程启动**：初始化和启动属性服务，并且启动Zygote进程。
- 5、**Zygote进程启动**：创建JVM并为其注册JNI方法，创建服务器端Socket，启动SystemServer进程。
- 6、**SystemServer进程启动**：启动Binder线程池和SystemServiceManager，并且启动各种系统服务。
- 7、**Launcher启动**：被SystemServer进程启动的AMS会启动Launcher，Launcher启动后会将已安装应用的快捷图标显示到系统桌面上。



## Activity 启动

来自：3分钟看懂Activity启动流程 https://www.jianshu.com/p/9ecea420eb52

![img](https://upload-images.jianshu.io/upload_images/1869462-882b8e0470adf85a.jpg)



## APK程序运行过程

来自内核 framework概述

1. ActivityThread main()开始执行，调用prepareMainLooper，为UI线程创建一个消息队列
2. 然后创建一个ActivityThread对象，在其初始化代码中会创建：
   1. H（Handler）对象
   2. ApplicationThread(Binder)对象——负责接收远程AmS的IPC调用，接收到调用后，通过Handler把消息发送到消息队列 >> UI主线程会异步的从消息队列取出消息执行响应操作
3. 接着，UI主线程调用Looper.loop方法进入消息循环，不断读取、处理消息
4. 当ActivityThread收到远程AmS发送的start某个Activity的消息后，就会创建指定Activity，Activity又会创建PhoneWindow 》DecorView》相应的View/ViewGroup
5. 需要把创建好的界面显示到屏幕上：调用WindowManager创建ViewRoot对象+W对象 >> WindowManager再调用WmS远程接口添加窗口到屏幕上
6. 用户开始再屏幕上操作，
   1. KeyQ线程不断把用户消息存储到QueueEvent队列中
   2. InputDispatcher线程逐个取出消息，调用WmS处理该消息
   3. WmS判定窗口归属，调用窗口的W对象接口
   4. W是一个Binder负责接收WmS的IPC调用，并把消息传递给ViewRoot，ViewRoot再把消息传递给UI主线程ActivityThread
   5. ActivityThread解析消息并做处理
   6. 消息处理流：DecorView >> 内部子View > PhoneWindow > Activity



###点击App图标

具体过程：

1. 用户点击App图标，`Lanuacher`进程通过`Binder`联系到`System Server`进程发起`startActivity`。
2. `System Server`通过`Socket`联系到`Zygote`，`fork`出一个新的App进程。
3. 创建出一个新的App进程以后，`Zygote`启动App进程的`ActivityThread#main()`方法。
4. 在`ActivtiyThread`中，调用`AMS`进行`ApplicationThread`的绑定。
5. `AMS`发送创建`Application`的消息给`ApplicationThread`，进而转交给`ActivityThread`中的`H`，它是一个`Handler`，接着进行`Application`的创建工作。
6. `AMS`以同样的方式创建`Activity`，接着就是大家熟悉的创建`Activity`的工作了。