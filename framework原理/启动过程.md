## Zygote与SystemServer

Android系统相对于Linux内核而言，也是一个应用程序而已，因此也在init.rc中被声明，然后Linux内核启动后，能够接着启动Android内核。



![image-20200430161101513](https://tva1.sinaimg.cn/large/007S8ZIlly1gebv01nzkmj30qu0jygs3.jpg)



系统中第一个Dalvik虚拟机程序叫做Zygote，接下来所有的进程都是由它创建

Zygote进程主要包括2个模块：

* Socket服务端：用于接收启动新进程的命令
* Framework共享类、共享资源：Zygote进程会装载一些共享类、资源，其他进程就不再需要加载了

Zygote进程对应的具体程序是app_process，存在于system/bin目录下，启动该程序的指令是在init.rc中配置的。

Zygote孵化出的第一个进程叫做SystemServer，其对应的具体程序也是app_process



SystemServer创建了一个Socket客户端，由Ams管理，之后新进程启动消息流程如下：

> SystemServer进程中的Ams > Socket客户端 >> Zygote进程中的Socket服务端



## Zygote的启动

### 1、在init.rc中配置Zygote的启动参数

init.rc存在于设备的根目录下： /init.rc

```bash
//语法：service service_name 可执行程序的路径 可执行程序自身所需的参数列表
service zygote /system/bin/app_ process -Xzygote /system/bin --zygote --start-system-server

socket zygote stream 666
onrestart write /sys/android_ power/ request_ state wake
onrestart write /sys/power/state on
onrestart restart medi a
onrestart restart netd

```

命令解析：

1. service：告诉操作系统将zygote程序加入到系统服务中
2. **zygote：**名称，其实可以任意
3. -Xzygote：虚拟机启动所需参数，
4. /system/bin ：虚拟机程序路径，注意区分上面可执行程序路径
5. **--zygote**：指明`ZygoteInit`类作为虚拟机执行入口，否则没有该参数需要指明入口类名
6. **--start-system-server**：告知ZygoteInit启动完成后，孵化第一个进程：`SystemServer`
7. onrestart：指定服务重启后所触发的操作



### 2、启动Socket服务端口

zygote服务从app_ process启动后，会启动一个Dalvik虚拟机，而虚拟机执行的第一个Java类是ZygoteInit.java

1. 流程从ZygoteInit的main()函数开始
   1. 启动一个Socket服务端口



### 3、加载preload_classes

创建完Socket服务端后，还不能立即孵化新进程，需要加载共享类、资源。

1. 预装的类列表是在`framework.jar`中的一个文本文件列表，名称为`preload-classes`, 

   该列表的原始定义在frameworks/base/preload-classes 文本文件中，

   而该文件又是通过frameworks/base/tool/preload/WritePreloadedClassFile.java类生成的。

   在Android源码编译的时候，会最终把preload-lasses文件打包到frameworkjar中

2. 有了这个列表后，ZygoteInit 中通过调用`preloadClasses()`完成装载这些类。

   * 装载的方法很简单，就是读取preload-classes列表中的每一行， 因为每一行代表了 一个具体的类，然后调用Class.forName()装载目标类

   

### 4、加载preload_resources

1. preload- resources是在frameworks/base/core/res/res/values/arrays.xml中被定义的

   包含两类资源:

   * drawable资源：preloadResources > preloadDrawables()加载
   * color资源：preloadResources > preloadColorStateLists()加载

2. 加载的原理：把这些资源读出来放到一个全局变量中（都是Resources：mResources），只要该类对象不被销毁，这些全局变量就会一直保存。



新版本还会有其他共享资源的加载：preloadSharedLibraries()：`libandroid.so` 、`libcompiler_rt.so` 和 `libjnigraphics.so`



### 5、使用fork启动新进程

>  fork是Linux系统的一个系统调用，其作用是复制当前进程，产生一个新的进程。
>
> 新进程将拥有和原始进程完全相同的进程信息，除了进程id不同。

为什么复制而不是创建？——进程共享大量程序，复制可以节省大量共享内存



fork()函数的返回值与普通函数调用完全不同

* 当返回值大于0时，代表的是父进程；
* 当等于0时，代表的是被复制的进程。

换句话说，父进程和子进程的代码都在该C文件中，只是不同的进程执行不同的代码，而进程是靠fork()的返回值进行区分的。



```java
// 1、ZygoteInit.java 的如下方法，复制一个新的进程
pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs. debugFlags, rlimits);

// 2、根据返回的pid不同，有不同的操作
if(pid==0){
  // 表示在子进程运行
  handleChildProc()
}else{
  handleParentProc()
}

// 3、而handleChildProc关键代码：
//当zygote复制新进程时，已经创建了一个Socket服务端，而这个服务端是不应该被新进程使用的，否则系统中会有多个进程接收Socket客户端的命令。因此，新进程被创建好后，首先需要在新进程中关闭该Socket 服务端
closeSocket();
ZygoteInit.closeServerSocket();

// 4、接着从指定Class文件的main()函数处开始执行:
	ZygoteInit.invokeStaticMain(cloader, className, mainArgs );

// 5、至此，新进程就完全脱离了zygote进程的孵化过程，成为一个真正的应用进程。
```



## SystemServer进程的启动

ZygoteInit.java : main() >> startSystemServer()，该函数有3个关键点：

1. 定义一个参数数组，指明进程启动后加载的第一个Java类：com.android. server.SystemServer
2. 孵化新进程：Zygote.forkSystemServer，类似于孵化其他进程的forkAndSpecialize
3. 关闭Socket服务端，执行SystemServer的main函数

`PS：`其实流程跟上面普通进程复制差不多，只是函数名不同



### 1、启动各种服务线程

AmS、PMS、WmS等都是以一个**线程**的形式存在于SystemServer进程中。

```java
//SystemServer伪代码
public static void main(){
  init1();// native 调用，处理DVM相关初始化
  init2();// 启动各种服务
}

private static final void init2(){
  Slog.i(TAG, "Entered the Android system server!");
	Thread thr = newServerThread();// 内部开始真正启动各种服务
	thr.setName("android.server.ServerThread");
	thr.start();
}
```

##### 启动模式

* 模式一：直接使用构造函数构造一个服务。由于大多数服务都对应一个线程，因此，在构造
  函数内部就会创建一个线程并自动运行。

* 模式二：服务类会提供一个getInstance()方法.通过该方法获取该服务对象，这样的好处是保
  证系统中仅包含一个该服务对象。

* 模式三：从服务类的main()函数中开始执行。

  



![image-20200501023038382](https://tva1.sinaimg.cn/large/007S8ZIlly1geccwp8nk1j314g0ew79b.jpg)



#####启动完成

当AmS执行完systemReady后，会相继启动相关联服务的systemReady()函数，完成整体初始化。



###2、启动第一个Activity

1. AmS的systemReady函数内部的最后一段代码则发出了启动任务队列中最上面一个Activity的消息:

   ```java
   mMainStack.resumeTopActivityLocked(null);
   ```

2. 由于系统刚启动时，mMainStack 队列中并没有任何Activity 对象，因此, ActivityStack 类中将调用
   startHomeActivityLocked函数

3. startHomeActivityLocked发出一个category字段包含CATEGORY_HOME的Intent

4. 启动声明响应该Intent的Home程序(用户可选择)

   



### Android系统启动流程是什么？

（提示：init进程 -> Zygote进程 –> SystemServer进程 –> 各种系统服务 –> 应用进程）

Android系统启动的核心流程如下：

- 1、**启动电源以及系统启动**：当电源按下时引导芯片从预定义的地方（固化在ROM）开始执行，加载引导程序BootLoader到RAM，然后执行。
- 2、**引导程序BootLoader**：BootLoader是在Android系统开始运行前的一个小程序，主要用于把系统OS拉起来并运行。
- 3、**Linux内核启动**：当内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。当其完成系统设置时，会先在系统文件中寻找init.rc文件，并启动init进程。
- 4、**init进程启动**：初始化和启动属性服务，并且启动Zygote进程。
- 5、**Zygote进程启动**：创建JVM并为其注册JNI方法，创建服务器端Socket，启动SystemServer进程。
- 6、**SystemServer进程启动**：启动Binder线程池和SystemServiceManager，并且启动各种系统服务。
- 7、**Launcher启动**：被SystemServer进程启动的AMS会启动Launcher，Launcher启动后会将已安装应用的快捷图标显示到系统桌面上。



## Activity 启动源码分析

下图来自：3分钟看懂Activity启动流程 https://www.jianshu.com/p/9ecea420eb52

![img](https://upload-images.jianshu.io/upload_images/1869462-882b8e0470adf85a.jpg)



下面的源码分析来自：https://blog.csdn.net/qq_30993595/java/article/details/81773286

结合这些源码，我整理了整体的流程图：



### 1、类介绍

这个章节的分析将会接触到大量跨进程通信，需要用到AIDL，其中涉及到的类如下，AIDL的实现模式都是固定的

一

* `IActivityManager：`作为应用进程请求系统进程的接口，这时候应用进程是客户端进程，系统进程是服务端进程，客户端和服务端进程都实现且遵循这个接口规则
* `ActivityManagerNative(AMN)`：作为服务端的“桩(Stub)”，其主要职责就是对远程（客户端进程）传递过来的数据进行”反序列化(unparcel)”
* `ActivityManagerProxy(AMP)`：作为服务的“代理(Proxy)”,运行在客户端进程，其主要职责就是将数据进行“序列化(parcel)”，再传递给远程的“桩(Stub)”
* `ActivityManagerService(AMS)`：IActivityManager接口中定义的业务的具体实现，运行在服务端，对“桩(Stub)”做了继承扩展



二

* `IApplicationThread`: **作为系统进程请求应用进程的接口**，这时候应用进程是服务端进程，系统进程是客户端进程，客户端和服务端进程都实现且遵循这个接口规则

* `ApplicationThread(APT)`：实现`IApplicationThread`接口，同理于ActivityManagerService，负责响应系统进程发起的请求，帮助AMS管理相关Application中的Activity的生命周期，是ActivityThread内部类（ActivityThread是应用进程的主线程），接收到系统进程请求后通过Handler往主线程发消息，这样ApplicationThread就轻松将具体执行任务的工作转交给了主线程，用来实现AMS和AT之间的交互

* `ApplicationThreadNative`：同理于ActivityManagerNative

* `ApplicationThreadProxy`：同理于ActivityManagerProxy

  

三

* `ProcessRecord`：保存了进程运行时的信息，AMS通过ProcessRecord来维护进程运行时的状态信息，需要将应用进程绑定到ProcessRecord才能开始一个Application的构建（每个应用进程在AMS对应一个ProcessRecord）
* `ActivityRecord`：保存Activity运行时的信息，AMS通过ActivityRecord来维护Activity运行时的状态信息，需要将Activity绑定到AMS中的ActivityRecord才能开始Activity的生命周期（每个Activity在AMS对应一个ActivityRecord，其实就是服务器端的Activity对象的映像）
* `TaskRecord`：AMS抽象出来的一个Task的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序，如果了解过Activity的启动模式就知道这个用处了
* `ActivityStack`：AMS对Activity设计的一种堆栈机制用于管理Activity，为了让这许多Activity协同工作而不至于产生混乱，其遵循先进后出的原则，系统总是显示位于栈顶的Activity

四

* `ActivityThread(AT)`：APP的入口类，从main方法开始执行，就是大家口中的UI线程或者主线程，与AMS一起完成四大组件的工作
* `Instrumentation`：每一个应用程序只有一个Instrumentation实例，在BindApplication创建的，每个Activity内部拥有一个该对象的引用，ActivityThread对组件的操作最后都是交给它去做具体的执行



### 2、在Launcher启动Activity

先通过PackageManager类的queryIntentActivities方法，获取所有需要展示的应用集合
将应用集合设置到adapter，然后绑定listview显示
每个item实体为ListItem对象，封装了要启动的应用的信息
重写onListItemClick方法，响应点击事件，启动相应的应用，说是启动应用，其实是启动这个应用在mainfest.xml中注册了android.intent.action.MAIN这个action的Activity

### 3、Activity.startActivity

不管是在桌面启动Activity还是在应用中启动Activity，最终都会走到同一处，也就是Activity类的startActivity方法

```java
@Override
public void startActivity(Intent intent) {
    this.startActivity(intent, null);
}

@Override
public void startActivity(Intent intent, @Nullable Bundle options) {
    if (options != null) {
        startActivityForResult(intent, -1, options);
    } else {
        startActivityForResult(intent, -1);
    }
}

public void startActivityForResult(@RequiresPermission Intent intent, int requestCode) {
    startActivityForResult(intent, requestCode, null);
}
```


```java
// startActivity，最后走到这里
public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,
        @Nullable Bundle options) {
  	// mParent即父Activity，现在没有这种用法了，都会走到这个条件分支
    if (mParent == null) {
        options = transferSpringboardActivityOptions(options);
        Instrumentation.ActivityResult ar =
            mInstrumentation.execStartActivity(
                this, mMainThread.getApplicationThread(), mToken, this,
                intent, requestCode, options);
        if (ar != null) {
            mMainThread.sendActivityResult(
                mToken, mEmbeddedID, requestCode, ar.getResultCode(),
                ar.getResultData());
        }
        if (requestCode >= 0) {
            mStartedActivity = true;
        }

        cancelInputsAndStartExitTransition(options);
        // TODO Consider clearing/flushing other event sources and events for child windows.
    } else {
        if (options != null) {
            mParent.startActivityFromChild(this, intent, requestCode, options);
        } else {
            // Note we want to go through this method for compatibility with
            // existing applications that may have overridden it.
            mParent.startActivityFromChild(this, intent, requestCode);
        }
    }
}

// 说明：
// mMainThread即ActivityThread
// mMainThread.getApplicationThread() 返回ApplicationThread，是ActivityThread的内部类
private class ApplicationThread extends IApplicationThread.Stub {
}

```

接下来就会执行到Instrumentation.execStartActivity方法了

### 4、Instrumentation.execStartActivity

**关键代码：**

```java
// IPC 调用，转到AMS执行
int result = ActivityManager.getService().startActivity
```

详情：

```java
// Instrumentation 类
// 参数：
/* who:当前Activity的上下文（context）
/* contextThread：ActivityThread的内部类ApplicationThread，继承ApplicationThreadNative；同时可以看到这是一个IBinder对象，说明它的作用就是用于进程间通讯的Binder对象
/* token：Activity的创建与关联时候(下面的内容会提到)传入的Activity信息，代表当前Activity，后续AMS可以通过它和contextThread知道是谁请求自己的
*/
public ActivityResult execStartActivity(
        Context who, IBinder contextThread, IBinder token, Activity target,
        Intent intent, int requestCode, Bundle options) {
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    Uri referrer = target != null ? target.onProvideReferrer() : null;
    if (referrer != null) {
        intent.putExtra(Intent.EXTRA_REFERRER, referrer);
    }
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i=0; i<N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                ActivityResult result = null;
                if (am.ignoreMatchingSpecificIntents()) {
                    result = am.onStartActivity(intent);
                }
                if (result != null) {
                    am.mHits++;
                    return result;
                } else if (am.match(who, null, intent)) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return requestCode >= 0 ? am.getResult() : null;
                    }
                    break;
                }
            }
        }
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(who);
      	// 通过AMS代理，IPC调用
        int result = ActivityManager.getService()
            .startActivity(whoThread, who.getBasePackageName(), intent,
                    intent.resolveTypeIfNeeded(who.getContentResolver()),
                    token, target != null ? target.mEmbeddedID : null,
                    requestCode, 0, null, options);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
    return null;
}

// ActivityManager.getService() 方法其实是通过AIDL返回一个AMS代理，然后AMS.startActivity
 public static IActivityManager getService() {
     return IActivityManagerSingleton.get();
 }

 private static final Singleton<IActivityManager> IActivityManagerSingleton =
         new Singleton<IActivityManager>() {
             @Override
             protected IActivityManager create() {
                 final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);
                 final IActivityManager am = IActivityManager.Stub.asInterface(b);
                 return am;
             }
         };
```

我们知道，每个应用程序都有一个主线程/UI线程，也就是`ActivityThread`，一个应用程序就是由ActivityThread这样一个主线程和若干个子线程组成的（像平时说的**Application代表一个应用，其实它是ActivityThread的上下文；例如Context是Activity的上下文**）；

ActivityThread管理着所有的Activity操作；但是又是谁去通知它做这些事呢？

没错，就是**ActivityManagerService(以下简称AMS)**了，AMS是服务端，整个手机上的应用中的Activity操作全部由它来进行调度，AMS与每个应用的ActivityThread处于不同的进程，它去通知ActivityThread就涉及到Binder通信了（Android中IPC）



### 5、AIDL转到AMS执行

```java
//以下是在AMS类中
@Override
    public final int startActivity(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {
      
        return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,
                resultWho, requestCode, startFlags, profilerInfo, bOptions,
                UserHandle.getCallingUserId());
    }

@Override
public final int startActivityAsUser(IApplicationThread caller, String callingPackage,
            Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode,
            int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
        //检查调用者是否有相应的权限
        enforceNotIsolatedCaller("startActivity");
        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(),
                userId, false, ALLOW_FULL_ONLY, "startActivity", null);
        // TODO: Switch to user app stacks here.
        return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent,
                resolvedType, null, null, resultTo, resultWho, requestCode, startFlags,
                profilerInfo, null, null, bOptions, false, userId, null, null);
    }

```



这个mActivityStarter是ActivityStarter，是一个Activity启动管理类，将Intent和flag转化成一个Activity及相关联的task和stack；以前老版本是直接用ActivityStackSupervisor处理

```java
final int startActivityMayWait(IApplicationThread caller, int callingUid,
            String callingPackage, Intent intent, String resolvedType,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            IBinder resultTo, String resultWho, int requestCode, int startFlags,
            ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config,
            Bundle bOptions, boolean ignoreTargetSecurity, int userId,
            IActivityContainer iContainer, TaskRecord inTask) {
            
				.......
				
				//根据给定的Intent，判断是否是显示启动
        ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);
        
        .......
        
        //根据Intent匹配相应的Activity ， 当存在多个可供选择的Activity,则直接向用户弹出resolveActivity
        ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);

				.......
				
        final ActivityRecord[] outRecord = new ActivityRecord[1];
            int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,
                    aInfo, rInfo, voiceSession, voiceInteractor,
                    resultTo, resultWho, requestCode, callingPid,
                    callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,
                    options, ignoreTargetSecurity, componentSpecified, outRecord, container,
                    inTask);
        return res;
}

final int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent,
            String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid,
            String callingPackage, int realCallingPid, int realCallingUid, int startFlags,
            ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,
            ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,
            TaskRecord inTask) {
        int err = ActivityManager.START_SUCCESS;

        .......
				
		//创建ActivityRecord对象
		//每次启动一个Actvity会有一个对应的ActivityRecord对象，代表Activity在堆栈的一个记录
        ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage,
                intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho,
                requestCode, componentSpecified, voiceSession != null, mSupervisor, container,
                options, sourceRecord);

  			.......

        err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags,
                    true, options, inTask);
        
        //将Activity对应的TASK移动到前台            
        postStartActivityUncheckedProcessing(r, err, stack.mStackId, mSourceRecord, mTargetStack);

        return err;
}

// 这个方法处理逻辑很复杂，比如我们平时启动activity的flag、taskAffinity属性都在这里处理
private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,
            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,
            int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) {

        .......
        mTargetStack.startActivityLocked(mStartActivity, newTask, mKeepCurTransition, mOptions);

		.......
		if (mDoResume) {
				mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,mOptions);
		}
        return START_SUCCESS;
}


```



### 6、ActivityStack.startActivityLocked

```java
final void startActivityLocked(ActivityRecord r, boolean newTask, boolean keepCurTransition,
            ActivityOptions options) {
        TaskRecord rTask = r.task;
        final int taskId = rTask.taskId;

        TaskRecord task = null;
        if (!newTask) {
            // 如果目标Activity不用新开task，那就从已存在的task中找出
            boolean startIt = true;
            for (int taskNdx = mTaskHistory.size() - 1; taskNdx >= 0; --taskNdx) {
                task = mTaskHistory.get(taskNdx);
                if (task.getTopActivity() == null) {
                    // 栈中的所有Activity正在finish
                    continue;
                }
                if (task == r.task) {
                    // 在这里添加
                    if (!startIt) {
                       
                        task.addActivityToTop(r);
                        r.putInHistory();
                        addConfigOverride(r, task);
                        if (VALIDATE_TOKENS) {
                            validateAppTokensLocked();
                        }
                        ActivityOptions.abort(options);
                        return;
                    }
                    break;
                } else if (task.numFullscreen > 0) {
                    startIt = false;
                }
            }
        }

        // 将Activity推到栈顶
        if (task == r.task && mTaskHistory.indexOf(task) != (mTaskHistory.size() - 1)) {
        		//如果没有将Activity推到栈顶，那么就不把onUserLeaving回调给当前Activity
            mStackSupervisor.mUserLeaving = false;
        }

        task = r.task;

        // 将Activity添加到历史栈中然后继续
        task.addActivityToTop(r);
        task.setFrontOfTask();

        r.putInHistory();
        if (!isHomeStack() || numActivities() > 0) {
            //如果我们要切换到一个新的栈，或者下一个Activity的进程不存在
            //那我们就需要展示一个预览窗口
            boolean showStartingIcon = newTask;
            ProcessRecord proc = r.app;
            if (proc == null) {
                proc = mService.mProcessNames.get(r.processName, r.info.applicationInfo.uid);
            }
            if (proc == null || proc.thread == null) {
                showStartingIcon = true;
            }

            if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) {
                mWindowManager.prepareAppTransition(TRANSIT_NONE, keepCurTransition);
                mNoAnimActivities.add(r);
            } else {
                mWindowManager.prepareAppTransition(newTask
                        ? r.mLaunchTaskBehind
                                ? TRANSIT_TASK_OPEN_BEHIND
                                : TRANSIT_TASK_OPEN
                        : TRANSIT_ACTIVITY_OPEN, keepCurTransition);
                mNoAnimActivities.remove(r);
            }
            addConfigOverride(r, task);
            boolean doShow = true;
            if (newTask) {
                if ((r.intent.getFlags() & Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) {
                    resetTaskIfNeededLocked(r, r);
                    doShow = topRunningNonDelayedActivityLocked(null) == r;
                }
            } else if (options != null && options.getAnimationType()
                    == ActivityOptions.ANIM_SCENE_TRANSITION) {
                doShow = false;
            }
            if (r.mLaunchTaskBehind) {
                // 不要为mLaunchTaskBehind做一个启动窗口。 更重要的是要确保告诉WindowManager即使它位于堆栈的后面，r也是可见的
                mWindowManager.setAppVisibility(r.appToken, true);
                ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);
            } else if (SHOW_APP_STARTING_PREVIEW && doShow) {
                // 弄清楚我们是否正在切换另一个与下一个Activity“具有相同起始图标”的Activity。
                // 这允许窗口管理器保留它先前创建的预览窗口（如果它仍有）
                ActivityRecord prev = r.task.topRunningActivityWithStartingWindowLocked();
                if (prev != null) {
                    // 出现以下情况不再重用之前的预览窗口 :
                    // (1) 当前Activity处于不同的栈
                    if (prev.task != r.task) {
                        prev = null;
                    }
                    // (2) 当前Activity已经显示了
                    else if (prev.nowVisible) {
                        prev = null;
                    }
                }
                //开启预览窗口
                r.showStartingWindow(prev, showStartingIcon);
            }
        } else {
            // 如果这是第一个Activity,不要做一些花里胡哨的动画效果
            // 因为目前还没有任何东西供它在上面展示
            // 在WindowManagerService中注册，这样才能显示出来
            addConfigOverride(r, task);
            ActivityOptions.abort(options);
            options = null;
        }
        if (VALIDATE_TOKENS) {
            validateAppTokensLocked();
        }
    }

void showStartingWindow(ActivityRecord prev, boolean createIfNeeded) {
        final CompatibilityInfo compatInfo =
                service.compatibilityInfoForPackageLocked(info.applicationInfo);
        final boolean shown = service.mWindowManager.setAppStartingWindow(
                appToken, packageName, theme, compatInfo, nonLocalizedLabel, labelRes, icon,
                logo, windowFlags, prev != null ? prev.appToken : null, createIfNeeded);
        if (shown) {
            mStartingWindowState = STARTING_WINDOW_SHOWN;
        }
    }
    
void addConfigOverride(ActivityRecord r, TaskRecord task) {
        final Rect bounds = task.updateOverrideConfigurationFromLaunchBounds();
        // TODO: VI deal with activity
        mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken,
                r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,
                (r.info.flags & FLAG_SHOW_FOR_ALL_USERS) != 0, r.userId, r.info.configChanges,
                task.voiceSession != null, r.mLaunchTaskBehind, bounds, task.mOverrideConfig,
                task.mResizeMode, r.isAlwaysFocusable(), task.isHomeTask(),
                r.appInfo.targetSdkVersion);
        r.taskConfigOverride = task.mOverrideConfig;
    }
```

这个方法主要是将Activity推到栈顶并且通知WindowManagerService，这样startActivity的一系列准备工作基本上完成了

这里还有一个重要的事情就是在应用进程创建之前会开启一个预览窗口，避免在创建进程的这段时间用户点击无响应的情况，这也就是为什么我们在第一次启动应用的时候会有一个短时间的黑屏或者白屏的现象，俗称闪屏

这时候再回到上一个方法，即ActivityStarter的startActivityUnchecked方法，继续调用ActivityStackSupervisor类的resumeFocusedStackTopActivityLocked方法

### 6.2、Supervisor.resumeTopActivity

```java
// ActivityStackSupervisor类
boolean resumeFocusedStackTopActivityLocked(
            ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) {
        //待启动Activity对应的Task为前台Task时，调用该Task对应ActivityStack的resumeTopActivityUncheckedLocked函数
        if (targetStack != null && isFocusedStack(targetStack)) {
            return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);
        }
        final ActivityRecord r = mFocusedStack.topRunningActivityLocked();
        //否则只是调用当前前台栈的resumeTopActivityUncheckedLocked
        if (r == null || r.state != RESUMED) {
            mFocusedStack.resumeTopActivityUncheckedLocked(null, null);
        }
        return false;
}

```



```java
// ActivityStack类
boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {
        if (mStackSupervisor.inResumeTopActivity) {
            //防止递归启动 保证每次只有一个Activity执行resumeTopActivityLocked()操作.
            return false;
        }

        boolean result = false;
        try {
            // 修改标志位 防止递归
            mStackSupervisor.inResumeTopActivity = true;
            if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) {
                mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN;
                mService.updateSleepIfNeededLocked();
            }
            result = resumeTopActivityInnerLocked(prev, options);
        } finally {
            mStackSupervisor.inResumeTopActivity = false;
        }
        return result;
}

```

ActivityStack.resumeTopActivityInnerLocked

```java
private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {
        if (DEBUG_LOCKSCREEN) mService.logLockScreen("");

        if (!mService.mBooting && !mService.mBooted) {
            // 系统还没准备好，不允许启动activity
            return false;
        }

        ActivityRecord parent = mActivityContainer.mParentActivity;
        if ((parent != null && parent.state != ActivityState.RESUMED) ||
                !mActivityContainer.isAttachedLocked()) {
            // 如果一个activity的父activity没有resumed，就不启动该子activity
            return false;
        }

				final TaskRecord prevTask = prev != null ? prev.task : null;
    		if (next == null) {
        	//找不到要启动的activity，就回到桌面activity
        	return isOnHomeDisplay() &&
                mStackSupervisor.resumeHomeStackTask(returnTaskType, prev, reason);
    		}

        // 如果要启动的activity就在栈顶，那就不做处理
        if (mResumedActivity == next && next.state == ActivityState.RESUMED &&
                    mStackSupervisor.allResumedActivitiesComplete()) {
            mWindowManager.executeAppTransition();
            mNoAnimActivities.clear();
            ActivityOptions.abort(options);
            return false;
        }

        .......

        // 处于睡眠关机，栈顶activity已经暂停的情况下
        if (mService.isSleepingOrShuttingDownLocked()
                && mLastPausedActivity == next
                && mStackSupervisor.allPausedActivitiesComplete()) {
            mWindowManager.executeAppTransition();
            mNoAnimActivities.clear();
            ActivityOptions.abort(options);
            return false;
        }

				.......


        // 如果当前正在暂停这个activity，直接返回
        if (!mStackSupervisor.allPausedActivitiesComplete()) {
            return false;
        }

        mStackSupervisor.setLaunchSource(next.info.applicationInfo.uid);

        // 需要暂停当前activity，然后resume要启动的activity
        final boolean dontWaitForPause = (next.info.flags & FLAG_RESUME_WHILE_PAUSING) != 0;
        //暂停其它所有堆栈中的或者返回栈中的activity
        boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, true, dontWaitForPause);
        if (mResumedActivity != null) {
            //暂停当前处于resume的mResumedActivity ，它也可能是Launchactivity
            pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause);
        }
        
        if (pausing) {
            // 如果待启动的activity已经启动过，就将这个activity所处的进程置于LRU列表的顶部，以免被杀重新启动浪费资源
            if (next.app != null && next.app.thread != null) {
                mService.updateLruProcessLocked(next.app, true, null);
            }
            return true;
        } 
        
        .......

        // 确保该Activity所在的应用程序不在停止
        try {
            AppGlobals.getPackageManager().setPackageStoppedState(
                    next.packageName, false, next.userId); /* TODO: Verify if correct userid */
        } catch (RemoteException e1) {
        } catch (IllegalArgumentException e) {
            Slog.w(TAG, "Failed trying to unstop package "
                    + next.packageName + ": " + e);
        }

        // 正在启动下一个Activity，需要告诉windowManager，前一个activity会被很快隐藏，这样在计算屏幕方向时，windowmanager就会忽略它
        boolean anim = true;
        if (prev != null) {
            if (prev.finishing) {
                if (mNoAnimActivities.contains(prev)) {
                    anim = false;
                    mWindowManager.prepareAppTransition(TRANSIT_NONE, false);
                } else {
                    mWindowManager.prepareAppTransition(prev.task == next.task
                            ? TRANSIT_ACTIVITY_CLOSE
                            : TRANSIT_TASK_CLOSE, false);
                }
                mWindowManager.setAppVisibility(prev.appToken, false);
            } else {
                if (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION,
                        "Prepare open transition: prev=" + prev);
                if (mNoAnimActivities.contains(next)) {
                    anim = false;
                    mWindowManager.prepareAppTransition(TRANSIT_NONE, false);
                } else {
                    mWindowManager.prepareAppTransition(prev.task == next.task
                            ? TRANSIT_ACTIVITY_OPEN
                            : next.mLaunchTaskBehind
                                    ? TRANSIT_TASK_OPEN_BEHIND
                                    : TRANSIT_TASK_OPEN, false);
                }
            }
        } else {
            if (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION, "Prepare open transition: no previous");
            if (mNoAnimActivities.contains(next)) {
                anim = false;
                mWindowManager.prepareAppTransition(TRANSIT_NONE, false);
            } else {
                mWindowManager.prepareAppTransition(TRANSIT_ACTIVITY_OPEN, false);
            }
        }

        Bundle resumeAnimOptions = null;
        if (anim) {
            ActivityOptions opts = next.getOptionsForTargetActivityLocked();
            if (opts != null) {
                resumeAnimOptions = opts.toBundle();
            }
            next.applyOptionsLocked();
        } else {
            next.clearOptionsLocked();
        }

        ActivityStack lastStack = mStackSupervisor.getLastStack();
        //如果要启动的activity所在进程已经存在，且activity已经启动过了
        if (next.app != null && next.app.thread != null) {

            // 如果上一个activity是半透明的，则强制对下一个activity进行可见性更新
            //以便将其添加到WM的打开应用列表
            final boolean lastActivityTranslucent = lastStack != null
                    && (!lastStack.mFullscreen
                    || (lastStack.mLastPausedActivity != null
                    && !lastStack.mLastPausedActivity.fullscreen));

            // 正在设置Activity为可见.
            if (!next.visible || next.stopped || lastActivityTranslucent) {
                mWindowManager.setAppVisibility(next.appToken, true);
            }

            // schedule launch ticks to collect information about slow apps.
            next.startLaunchTickingLocked();

            ActivityRecord lastResumedActivity =
                    lastStack == null ? null :lastStack.mResumedActivity;
            ActivityState lastState = next.state;

            mService.updateCpuStats();

            //设置待启动Activity状态为resume
            next.state = ActivityState.RESUMED;
            //设置当前activity为当前活动activity
            mResumedActivity = next;
            next.task.touchActiveTime();
            mRecentTasks.addLocked(next.task);
            mService.updateLruProcessLocked(next.app, true, null);
            updateLRUListLocked(next);
            mService.updateOomAdjLocked();

            // 让WM基于新的activity顺序重新评估屏幕方向
            boolean notUpdated = true;
            if (mStackSupervisor.isFocusedStack(this)) {
                Configuration config = mWindowManager.updateOrientationFromAppTokens(
                        mService.mConfiguration,
                        next.mayFreezeScreenLocked(next.app) ? next.appToken : null);
                if (config != null) {
                    next.frozenBeforeDestroy = true;
                }
                notUpdated = !mService.updateConfigurationLocked(config, next, false);
            }

            ......

            try {
                // 分发所有pending结果
                ArrayList<ResultInfo> a = next.results;
                if (a != null) {
                    final int N = a.size();
                    if (!next.finishing && N > 0) {、
                        next.app.thread.scheduleSendResult(next.appToken, a);
                    }
                }

                if (next.newIntents != null) {
                		//如果Intent不为空，回调NewIntent方法传入Intent
                    next.app.thread.scheduleNewIntent(next.newIntents, next.appToken);
                }

                // 应用程序不再会被stop
                mWindowManager.notifyAppStopped(next.appToken, false);

                //回调onResume
                next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState,
                        mService.isNextTransitionForward(), resumeAnimOptions);

                mStackSupervisor.checkReadyForSleepLocked();

            } catch (Exception e) {
                // 恢复activity出现异常，比如activity被销毁了，那就重启这个activity
                next.state = lastState;
                if (lastStack != null) {
                    lastStack.mResumedActivity = lastResumedActivity;
                }
                if (!next.hasBeenLaunched) {
                    next.hasBeenLaunched = true;
                } else  if (SHOW_APP_STARTING_PREVIEW && lastStack != null &&
                        mStackSupervisor.isFrontStack(lastStack)) {
                    next.showStartingWindow(null, true);
                }
                mStackSupervisor.startSpecificActivityLocked(next, true, false);
                if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
                return true;
            }

            // From this point on, if something goes wrong there is no way
            // to recover the activity.
            try {
                completeResumeLocked(next);
            } catch (Exception e) {
                // If any exception gets thrown, toss away this
                // activity and try the next one.
                Slog.w(TAG, "Exception thrown during resume of " + next, e);
                requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, null,
                        "resume-exception", true);
                if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();
                return true;
            }
        } else {
            // 到这里就需要重新启动activity，或者创建进程启动activity
            if (!next.hasBeenLaunched) {
                next.hasBeenLaunched = true;
            } else {
                if (SHOW_APP_STARTING_PREVIEW) {
                    next.showStartingWindow(null, true);
                }
            }
            mStackSupervisor.startSpecificActivityLocked(next, true, true);
        }

        return true;
}
```



resumeTopActivityInnerLocked这个方法也是比较复杂的，主要会有以下判断处理

> 系统没有准备好，不予启动
> 待启动activity的父activity没有启动，不予启动
> 找不到要启动的activity，不予启动
> 当mResumedActivity不为null，即当前activity不为空，就pause当前activity
> 如果待启动的activity所在应用程序存在且activity已经启动过了，就resume这个activity
> 否则就重新启动这个activity或者创建应用进程再启动这个activity



### 8、重启Activity/创建进程

需要重新启动或者创建进程的话就进入下面方法：

```java
void startSpecificActivityLocked(ActivityRecord r,
            boolean andResume, boolean checkConfig) {
        // 判断Activity所在的应用程序是否还在
        ProcessRecord app = mService.getProcessRecordLocked(r.processName,
                r.info.applicationInfo.uid, true);

        r.task.stack.setLaunchTime(r);

        if (app != null && app.thread != null) {
            try {
                if ((r.info.flags&ActivityInfo.FLAG_MULTIPROCESS) == 0
                        || !"android".equals(r.info.packageName)) {
                   
                    app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,
                            mService.mProcessStats);
                }
                //这里表明待启动activity的应用已经启动了，那么就启动activity
                realStartActivityLocked(r, app, andResume, checkConfig);
                return;
            } catch (RemoteException e) {
                Slog.w(TAG, "Exception when starting activity "
                        + r.intent.getComponent().flattenToShortString(), e);
            }

        }
		//否则就通过zygote进程fork应用进程，然后启动activity
        mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,
                "activity", r.intent.getComponent(), false, false, true);
}

```

其实Android中的四大组件的使用startactivity，startService，sendBrocast，ContentResolver.query，如果判断这些组件所在进程不存在，最终都会走到AMS的startProcessLocked方法，这个方法主要一点就是通知Zygote进程（AMS处于system-server进程，这就涉及到system-server进程和Zygote进程之间的通信，Android在这里使用的是Socket作为IPC方式）去fork一个APP进程


```java
// AMS 请求创建进程 关键代码
private final void startProcessLocked(ProcessRecord app, String hostingType,
            String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
            // 请求zygote创建进程，成功后会返回新进程的pid，否则会抛出异常
            //ProcessStartResult是Process内部类，封装了启动进程的结果
            //这是一个阻塞过程
            Process.ProcessStartResult startResult = Process.start(entryPoint,
                    app.processName, uid, uid, gids, debugFlags, mountExternal,
                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,
                    app.info.dataDir, entryPointArgs);
            checkTime(startTime, "startProcess: returned from zygote!");
            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);

            ......
            
            //重置ProcessRecord的成员变量
            app.setPid(startResult.pid);
            app.usingWrapper = startResult.usingWrapper;
            app.removed = false;
            app.killed = false;
            app.killedByAm = false;
            checkTime(startTime, "startProcess: starting to update pids map");
            
            synchronized (mPidsSelfLocked) {
                ProcessRecord oldApp;
                // 如果已经有一个app占用了这个尚未清理的pid
                if ((oldApp = mPidsSelfLocked.get(startResult.pid)) != null && !app.isolated) {
                    // 清理与此pid相关联的内容   
                    cleanUpApplicationRecordLocked(oldApp, false, false, -1,
                            true /*replacingPid*/);
                }
                //将新创建的进程添加到mPidsSelfLocked
                this.mPidsSelfLocked.put(startResult.pid, app);
                if (isActivityProcess) {
                    Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                    msg.obj = app;
                    mHandler.sendMessageDelayed(msg, startResult.usingWrapper
                            ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);
                }
            }
            checkTime(startTime, "startProcess: done updating pids map");
        } catch (RuntimeException e) {
            // 创建进程失败了，一个常见的情况是由于主动升级导致包被冻结
            forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false,
                    false, true, false, false, UserHandle.getUserId(app.userId), "start failure");
        }
    }

```

这个方法中最重要的就是调用Process.start；然后通过socket向Zygote进程发送创建新进程的请求；Zygote进程启动后有一个runSelectLoop循环，当收到客户端请求便会执行ZygoteConnection.runOnce()方法，再经过层层调用后fork出新的应用进程，创建新进程后将ActivityThread类加载到新进程，并调用ActivityThread.main()方法

###9、ActivityThread.main

```java
// ActivityThread类
public static void main(String[] args) {
		......
				
		//实例化了UserEnvironment，便于访问存储路径
		//像平时使用的Environment.getExternalStorageDirectory出自UserEnvironment类
        Environment.initForCurrentUser();

        // 设置路径 确保用户能正确访问CA证书
        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());
        TrustedCertificateStore.setDefaultUserDirectory(configDir);

		//设置进程名，Process类是进程管理器
        Process.setArgV0("<pre-initialized>");

		//创建主线程的Looper
        Looper.prepareMainLooper();

		//创建ActivityThread 对象，并关联到AMS
        ActivityThread thread = new ActivityThread();
        thread.attach(false);

		//对主线程Handler赋值
        if (sMainThreadHandler == null) {
            sMainThreadHandler = thread.getHandler();
        }

        // 开启主线程循环器，不断的读取消息 派发处理消息
        Looper.loop();

        throw new RuntimeException("Main thread loop unexpectedly exited");
    }
```

这个方法代码不多，但是有三处比较重要

* 创建主线程的Looper，并调用Loop方法，这样主线程就有了自己的消息队列并不停的从中取消息，然后处理；

* 创建ActivityThread 对象，这个过程中会实例化几个重要的成员变量

  > ApplicationThread mAppThread = new ApplicationThread()
  > Looper mLooper = Looper.myLooper() 获取主线程的Looper
  > H mH = new H() H继承Handler，用来处理组件的生命周期

* 调用attach方法，这个方法很重要，看下方

### 10、ActivityThread.attach

```java
private void attach(boolean system) {
        sCurrentActivityThread = this;
        mSystemThread = system;//mSystemThread表明是system app 还是普通app
        if (!system) { //main方法传入的是false
            ViewRootImpl.addFirstDrawHandler(new Runnable() {
                @Override
                public void run() {
                	//开启JIT
                    ensureJitEnabled();
                }
            });
            android.ddm.DdmHandleAppName.setAppName("<pre-initialized>",
                                                    UserHandle.myUserId());
            //设置标识此应用程序/进程的对象，以报告VM错误。
            RuntimeInit.setApplicationObject(mAppThread.asBinder());
            //创建ActivityManagerProxy对象
            final IActivityManager mgr = ActivityManagerNative.getDefault();
            try {
            	//通过Binder跨进程调用AMS中的attachApplication
                mgr.attachApplication(mAppThread);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
            //观察是否到heap内存上限
            BinderInternal.addGcWatcher(new Runnable() {
                @Override public void run() {
                    if (!mSomeActivitiesChanged) {
                        return;
                    }
                    Runtime runtime = Runtime.getRuntime();
                    long dalvikMax = runtime.maxMemory();
                    long dalvikUsed = runtime.totalMemory() - runtime.freeMemory();
                    if (dalvikUsed > ((3*dalvikMax)/4)) {
                        if (DEBUG_MEMORY_TRIM) Slog.d(TAG, "Dalvik max=" + (dalvikMax/1024)
                                + " total=" + (runtime.totalMemory()/1024)
                                + " used=" + (dalvikUsed/1024));
                        mSomeActivitiesChanged = false;
                        try {
                        		//当已使用内存超过虚拟机总内存的3/4，就请求释放内存
                            mgr.releaseSomeActivities(mAppThread);
                        } catch (RemoteException e) {
                            throw e.rethrowFromSystemServer();
                        }
                    }
                }
            });
        } else {
            // 不要在这里设置application，如果系统崩溃，我们没办法显示警告信息
            android.ddm.DdmHandleAppName.setAppName("system_process",
                    UserHandle.myUserId());
            try {
                mInstrumentation = new Instrumentation();
                ContextImpl context = ContextImpl.createAppContext(
                        this, getSystemContext().mPackageInfo);
                mInitialApplication = context.mPackageInfo.makeApplication(true, null);
                mInitialApplication.onCreate();
            } catch (Exception e) {
                throw new RuntimeException(
                        "Unable to instantiate Application():" + e.toString(), e);
            }
        }

        //添加dropbox日志到libcore
        DropBox.setReporter(new DropBoxReporter());
		//添加Config回调接口
        ViewRootImpl.addConfigCallback(new ComponentCallbacks2() {
            @Override
            public void onConfigurationChanged(Configuration newConfig) {
                synchronized (mResourcesManager) {
                    // We need to apply this change to the resources
                    // immediately, because upon returning the view
                    // hierarchy will be informed about it.
                    if (mResourcesManager.applyConfigurationToResourcesLocked(newConfig, null)) {
                        updateLocaleListFromAppContext(mInitialApplication.getApplicationContext(),
                                mResourcesManager.getConfiguration().getLocales());

                        // This actually changed the resources!  Tell
                        // everyone about it.
                        if (mPendingConfiguration == null ||
                                mPendingConfiguration.isOtherSeqNewer(newConfig)) {
                            mPendingConfiguration = newConfig;

                            sendMessage(H.CONFIGURATION_CHANGED, newConfig);
                        }
                    }
                }
            }
            @Override
            public void onLowMemory() {
            }
            @Override
            public void onTrimMemory(int level) {
            }
        });
    }
```

### 11、IPC：AMS  attachApplication

```java
// IPC 调用，让AMS执行该命令
mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0);
```

这里最终调用到了native层，接下来经过一系列函数调用，最终调用到了**talkWithDriver()**跟驱动交互，这个函数最后通过`ioctl`系统调用，Client进程陷入内核态，Client调用attachApplication方法的线程挂起等待返回；驱动完成一系列的操作之后唤醒AMS所在进程，调用了AMS所在进程本地对象的onTransact函数（实际上由Server端线程池完成），这里就调用了AMN的onTransact方法（AMN即Binder本地对象）



从这里开始就正式进入AMS了：

```java
		// 这里的thread就是ATP了，AMS就用这个跟APP进程的APT通信
		@Override
    public final void attachApplication(IApplicationThread thread) {
        synchronized (this) {
        	//获取正在attach的应用进程id
            int callingPid = Binder.getCallingPid();
            final long origId = Binder.clearCallingIdentity();
            attachApplicationLocked(thread, callingPid);
            Binder.restoreCallingIdentity(origId);
        }
    }
```



####AMS.attachApplicationLocked

```java
		
private final boolean attachApplicationLocked(IApplicationThread thread,
            int pid) {

        // 通过pid查找正在attach的application record
        ProcessRecord app;
        if (pid != MY_PID && pid >= 0) {
            synchronized (mPidsSelfLocked) {
                app = mPidsSelfLocked.get(pid);
            }
        } else {
            app = null;
        }

        if (app == null) {
			//找不到对应的ProcessRecord，就杀掉pid对应的进程
            if (pid > 0 && pid != MY_PID) {
                Process.killProcessQuiet(pid);
                //TODO: killProcessGroup(app.info.uid, pid);
            } else {
                try {
                	//退出这个应用进程的Looper
                    thread.scheduleExit();
                } catch (Exception e) {
                    // Ignore exceptions.
                }
            }
            return false;
        }

        // 第一次attach，app.thread应该为null
        //如果不为null，说明attach在之前的进程，那就清除它
        if (app.thread != null) {
            handleAppDiedLocked(app, true, true);
        }

        // 述说整个进程
        
        final String processName = app.processName;
        try {
        	//注册该进程的死亡回调
            AppDeathRecipient adr = new AppDeathRecipient(
                    app, pid, thread);
            thread.asBinder().linkToDeath(adr, 0);
            app.deathRecipient = adr;
        } catch (RemoteException e) {
            app.resetPackageList(mProcessStats);
            startProcessLocked(app, "link fail", processName);
            return false;
        }

        EventLog.writeEvent(EventLogTags.AM_PROC_BOUND, app.userId, app.pid, app.processName);

		//设置应用进程信息
				
		//这一步结束，app.thread就不会为null
        app.makeActive(thread, mProcessStats);
        app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ;
        app.curSchedGroup = app.setSchedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        app.forcingToForeground = null;
        updateProcessForegroundLocked(app, false, false);
        app.hasShownUi = false;
        app.debugging = false;
        app.cached = false;
        app.killedByAm = false;

        // 使用此标志来决定当用户在稍后解锁时是否需要安装provider
        app.unlocked = StorageManager.isUserKeyUnlocked(app.userId);
		//移出进程启动超时消息
        mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);

        boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info);
        List<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;
				
		//如果应用程序中存在正在启动的providers，那就延迟10s发送Contentprovider超时消息
        if (providers != null && checkAppInLaunchingProvidersLocked(app)) {
            Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);
            msg.obj = app;
            mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);
        }

        try {

			//获取ApplicationInfo。它保存了从AndroidManifest.xml中检索出的application标签下的信息
            ApplicationInfo appInfo = app.instrumentationInfo != null
                    ? app.instrumentationInfo : app.info;
            app.compat = compatibilityInfoForPackageLocked(appInfo);
            if (profileFd != null) {
                profileFd = profileFd.dup();
            }
            //用于传递profiler设置的系统私有api
            ProfilerInfo profilerInfo = profileFile == null ? null
                    : new ProfilerInfo(profileFile, profileFd, samplingInterval, profileAutoStop);
            //绑定应用
            thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,
                    profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,
                    app.instrumentationUiAutomationConnection, testMode,
                    mBinderTransactionTrackingEnabled, enableTrackAllocation,
                    isRestrictedBackupMode || !normalMode, app.persistent,
                    new Configuration(mConfiguration), app.compat,
                    getCommonServicesLocked(app.isolated),
                    mCoreSettingsObserver.getCoreSettingsLocked());
            //更新进程lru列表
            updateLruProcessLocked(app, false, null);
            app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();
        } catch (Exception e) {
            // 如果bind失败，那就重启app进程，有可能会无限循环
            app.resetPackageList(mProcessStats);
            app.unlinkDeathRecipient();
            startProcessLocked(app, "bind fail", processName);
            return false;
        }

        // 从待启动应用列表清除这个ProcessRecord
        mPersistentStartingProcesses.remove(app);
        mProcessesOnHold.remove(app);

        boolean badApp = false;
        boolean didSomething = false;

        // 检测最顶层的可见activity是否正在等待运行在这个进程（启动activity !!!!!）
        if (normalMode) {
            try {
                if (mStackSupervisor.attachApplicationLocked(app)) {
                    didSomething = true;//didSomething表示是否有启动四大组件
                }
            } catch (Exception e) {
                badApp = true;
            }
        }

        // 查找所有要运行在这个进程中的sevice
        if (!badApp) {
            try {
                didSomething |= mServices.attachApplicationLocked(app, processName);
            } catch (Exception e) {
                badApp = true;
            }
        }

        // 检测这个进程是否有下一个Broadcast receiver
        if (!badApp && isPendingBroadcastProcessLocked(pid)) {
            try {
                didSomething |= sendPendingBroadcastsLocked(app);
            } catch (Exception e) {
                // 如果app因为尝试启动Broadcast receiver而死亡，就设置badApp = true
                badApp = true;
            }
        }

        //检查下一个backup代理是否在此过程中
        if (!badApp && mBackupTarget != null && mBackupTarget.appInfo.uid == app.uid) {
            notifyPackageUse(mBackupTarget.appInfo.packageName,
                             PackageManager.NOTIFY_PACKAGE_USE_BACKUP);
            try {
                thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,
                        compatibilityInfoForPackageLocked(mBackupTarget.appInfo),
                        mBackupTarget.backupMode);
            } catch (Exception e) {
                badApp = true;
            }
        }

		//如果以上组件启动出错，则需要杀死进程并移除记录
        if (badApp) {
            app.kill("error during init", true);
            handleAppDiedLocked(app, false, true);
            return false;
        }
		
		//如果没有启动任何组件，那么didSomething为false
		//调整进程的oom_adj值， oom_adj相当于一种优先级
        //当内存出现不足时，该进程是最先被系统“杀死”
        if (!didSomething) {
            updateOomAdjLocked();
        }

        return true;
    }
```

**总结：**

1. 通过pid查找当前进程对应的ProcessRecord
2. 如果ProcessRecord == null，说明正在attach的进程不存在，如果pid有效就杀掉pid对应的进程；反之让刚创建的activitythread退出looper循环；最后直接return
3. 如果查找出来的ProcessRecord 中保存的IApplicationThread不为空，说明它是上个进程的，那就需要清除它
   注册该进程的死亡回调，当进程死亡时会通过binder回调,来通知system_server进程死亡的消息
4. 重新设置ProcessRecord信息
5. 调用thread.bindApplication绑定Application到ActivityThread
6. 绑定应用：处理activity，service，Broadcast receiver
7. kill掉bad应用



### 12、APT.bindApplication

再次通过IPC调用，回到app进程

```java
// ApplicationThread
public final void bindApplication(String processName, ApplicationInfo appInfo,
                List<ProviderInfo> providers, ComponentName instrumentationName,
                ProfilerInfo profilerInfo, Bundle instrumentationArgs,
                IInstrumentationWatcher instrumentationWatcher,
                IUiAutomationConnection instrumentationUiConnection, int debugMode,
                boolean enableBinderTracking, boolean trackAllocation,
                boolean isRestrictedBackupMode, boolean persistent, Configuration config,
                CompatibilityInfo compatInfo, Map<String, IBinder> services, Bundle coreSettings) {

            if (services != null) {
                // Setup the service cache in the ServiceManager
                ServiceManager.initServiceCache(services);
            }

            setCoreSettings(coreSettings);

            AppBindData data = new AppBindData();
            data.processName = processName;
            data.appInfo = appInfo;
            data.providers = providers;
            data.instrumentationName = instrumentationName;
            data.instrumentationArgs = instrumentationArgs;
            data.instrumentationWatcher = instrumentationWatcher;
            data.instrumentationUiAutomationConnection = instrumentationUiConnection;
            data.debugMode = debugMode;
            data.enableBinderTracking = enableBinderTracking;
            data.trackAllocation = trackAllocation;
            data.restrictedBackupMode = isRestrictedBackupMode;
            data.persistent = persistent;
            data.config = config;
            data.compatInfo = compatInfo;
            data.initProfilerInfo = profilerInfo;
            sendMessage(H.BIND_APPLICATION, data);
        }
        
        public void setCoreSettings(Bundle coreSettings) {
            sendMessage(H.SET_CORE_SETTINGS, coreSettings);
        }
```

这里通过handler向主线程（AT）发送了两条消息SET_CORE_SETTINGS，BIND_APPLICATION

### 13、H Handler处理消息

```java
// ActivityThread 类
private class H extends Handler {
			public void handleMessage(Message msg) {
            switch (msg.what) {
            case SET_CORE_SETTINGS:
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "setCoreSettings");
                    handleSetCoreSettings((Bundle) msg.obj);
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                    break;
            case BIND_APPLICATION:
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "bindApplication");
                    AppBindData data = (AppBindData)msg.obj;
                    handleBindApplication(data);
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                    break;
            }
      }

}

private void handleSetCoreSettings(Bundle coreSettings) {
        synchronized (mResourcesManager) {
            mCoreSettings = coreSettings;
        }
        onCoreSettingsChange();
    }
    
    private void onCoreSettingsChange() {
        boolean debugViewAttributes =
                mCoreSettings.getInt(Settings.Global.DEBUG_VIEW_ATTRIBUTES, 0) != 0;
        if (debugViewAttributes != View.mDebugViewAttributes) {
            View.mDebugViewAttributes = debugViewAttributes;

            // 要求所有activity重启以进行更改
            for (Map.Entry<IBinder, ActivityClientRecord> entry : mActivities.entrySet()) {
                requestRelaunchActivity(entry.getKey(), null, null, 0, false, null, null, false,
                        false /* preserveWindow */);
            }
        }
    }


```

#### 13.2 handleBindApplication

```java
private void handleBindApplication(AppBindData data) {

        // 将UI线程作为sensitive thread 注册到虚拟机.
        VMRuntime.registerSensitiveThread();
        if (data.trackAllocation) {
            DdmVmInternal.enableRecentAllocations(true);
        }

        // 设置进程启动时间
        Process.setStartTimes(SystemClock.elapsedRealtime(), SystemClock.uptimeMillis());

        mBoundApplication = data;
        mConfiguration = new Configuration(data.config);
        mCompatConfiguration = new Configuration(data.config);

        mProfiler = new Profiler();
        if (data.initProfilerInfo != null) {
            mProfiler.profileFile = data.initProfilerInfo.profileFile;
            mProfiler.profileFd = data.initProfilerInfo.profileFd;
            mProfiler.samplingInterval = data.initProfilerInfo.samplingInterval;
            mProfiler.autoStopProfiler = data.initProfilerInfo.autoStopProfiler;
        }

        // 设置进程名, 也就是说进程名是在进程真正创建以后的BIND_APPLICATION过程中才取名
        Process.setArgV0(data.processName);
        android.ddm.DdmHandleAppName.setAppName(data.processName,
                                                UserHandle.myUserId());

        if (data.persistent) {
            // Persistent processes on 在低内存设备上无法使用硬件加速绘图，禁用以节省内存
            if (!ActivityManager.isHighEndGfx()) {
                ThreadedRenderer.disable(false);
            }
        }

        if (mProfiler.profileFd != null) {
            mProfiler.startProfiling();
        }

        // 如果sdk版本在Android3.1.x(API12)或更早版本，需要设置Asynctask中使用的线程池，这样任务是并行执行，在高版本是串行执行
        if (data.appInfo.targetSdkVersion <= android.os.Build.VERSION_CODES.HONEYCOMB_MR1) {
            AsyncTask.setDefaultExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
        }

		//如果版本大于LOLLIPOP，就不支持回收正在使用的Message
        Message.updateCheckRecycle(data.appInfo.targetSdkVersion);

        /*
         * 重置时区
         */
        TimeZone.setDefault(null);
        LocaleList.setDefault(data.config.getLocales());

        synchronized (mResourcesManager) {
            /*
             * 更新系统配置
             */
            mResourcesManager.applyConfigurationToResourcesLocked(data.config, data.compatInfo);
            mCurDefaultDisplayDpi = data.config.densityDpi;
            applyCompatConfiguration(mCurDefaultDisplayDpi);
        }

		//获取LoadedApk对象
        data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);
        
		//api11以后禁止在主线程使用网络
		if (data.appInfo.targetSdkVersion >= Build.VERSION_CODES.HONEYCOMB) {
            StrictMode.enableDeathOnNetwork();
        }
        
		//api24及以后禁止使用file://这种格式的Uri；引入Fileprovide
		if (data.appInfo.targetSdkVersion >= Build.VERSION_CODES.N) {
            StrictMode.enableDeathOnFileUriExposure();
        }
       ......

        /**
         * 因为前面重置了时区，所以这里需要初始化http代理.
         * 这里也是AIDL的运用
         */
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Setup proxies");
        final IBinder b = ServiceManager.getService(Context.CONNECTIVITY_SERVICE);
        if (b != null) {
            final IConnectivityManager service = IConnectivityManager.Stub.asInterface(b);
            try {
                final ProxyInfo proxyInfo = service.getProxyForNetwork(null);
                Proxy.setHttpProxySystemProperty(proxyInfo);
            } catch (RemoteException e) {
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                throw e.rethrowFromSystemServer();
            }
        }
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);

        // Instrumentation会影响类加载器，所以在设置app的context之前初始化.
        final InstrumentationInfo ii;
        if (data.instrumentationName != null) {
            try {
                ii = new ApplicationPackageManager(null, getPackageManager())
                        .getInstrumentationInfo(data.instrumentationName, 0);
            } catch (PackageManager.NameNotFoundException e) {
                throw new RuntimeException(
                        "Unable to find instrumentation info for: " + data.instrumentationName);
            }

            mInstrumentationPackageName = ii.packageName;
            mInstrumentationAppDir = ii.sourceDir;
            mInstrumentationSplitAppDirs = ii.splitSourceDirs;
            mInstrumentationLibDir = getInstrumentationLibrary(data.appInfo, ii);
            mInstrumentedAppDir = data.info.getAppDir();
            mInstrumentedSplitAppDirs = data.info.getSplitAppDirs();
            mInstrumentedLibDir = data.info.getLibDir();
        } else {
            ii = null;
        }
        
		//创建ContextImpl上下文
        final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);
        updateLocaleListFromAppContext(appContext,
                mResourcesManager.getConfiguration().getLocales());

        if (!Process.isIsolated() && !"android".equals(appContext.getPackageName())) {
            final File cacheDir = appContext.getCacheDir();
            if (cacheDir != null) {
                // 设置临时文件缓存目录
                System.setProperty("java.io.tmpdir", cacheDir.getAbsolutePath());
            } 
            // 设置 generated/compiled graphics code 的缓存位置.
            final Context deviceContext = appContext.createDeviceProtectedStorageContext();
            final File codeCacheDir = deviceContext.getCodeCacheDir();
            if (codeCacheDir != null) {
                setupGraphicsSupport(data.info, codeCacheDir);
            } 
        }

        // 安装 Network Security Config Provider. 必须在应用程序代码加载前安装
        NetworkSecurityConfigProvider.install(appContext);

        // 继续实例化instrumentation.
        if (ii != null) {
            final ApplicationInfo instrApp = new ApplicationInfo();
            ii.copyTo(instrApp);
            instrApp.initForUser(UserHandle.myUserId());
            final LoadedApk pi = getPackageInfo(instrApp, data.compatInfo,
                    appContext.getClassLoader(), false, true, false);
            final ContextImpl instrContext = ContextImpl.createAppContext(this, pi);

            try {
                final ClassLoader cl = instrContext.getClassLoader();
                mInstrumentation = (Instrumentation)
                    cl.loadClass(data.instrumentationName.getClassName()).newInstance();
            } catch (Exception e) {
                throw new RuntimeException(
                    "Unable to instantiate instrumentation "
                    + data.instrumentationName + ": " + e.toString(), e);
            }

            final ComponentName component = new ComponentName(ii.packageName, ii.name);
            mInstrumentation.init(this, instrContext, appContext, component,
                    data.instrumentationWatcher, data.instrumentationUiAutomationConnection);

            if (mProfiler.profileFile != null && !ii.handleProfiling
                    && mProfiler.profileFd == null) {
                mProfiler.handlingProfiling = true;
                final File file = new File(mProfiler.profileFile);
                file.getParentFile().mkdirs();
                Debug.startMethodTracing(file.toString(), 8 * 1024 * 1024);
            }
        } else {
        	//第一次进来肯定是null，在这里实例化，所有activity的生命周期方法回调前都会调用该对象相关方法
            mInstrumentation = new Instrumentation();
        }

        if ((data.appInfo.flags&ApplicationInfo.FLAG_LARGE_HEAP) != 0) {
        	//清除内存增长上限
            dalvik.system.VMRuntime.getRuntime().clearGrowthLimit();
        } else {
            // Small heap, clamp to the current growth limit and let the heap release
            // pages after the growth limit to the non growth limit capacity. b/18387825
            dalvik.system.VMRuntime.getRuntime().clampGrowthLimit();
        }

        // 应用程序和provider在设置期间允许磁盘访问，这有可能会阻塞ordered broadcasts的处理
        final StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites();
        try {
            // 此处data.info是指LoadedApk, 通过反射创建目标应用Application对象
            Application app = data.info.makeApplication(data.restrictedBackupMode, null);
            mInitialApplication = app;

            // 不要在 restricted 模式中提供provider; 他们可能依赖于APP自定义的类
            if (!data.restrictedBackupMode) {
                if (!ArrayUtils.isEmpty(data.providers)) {
                    installContentProviders(app, data.providers);
                    // 对于包含content provider的进程，我们希望在某个时刻启用JIT
                    mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000);
                }
            }

			//在mInstrumentation启动时，在加载任何应用程序代码之前调用。 
			//通常会被重写调用{@link #start}来开始检测线程，然后将继续在{@link #onStart}中执行。
            try {
                mInstrumentation.onCreate(data.instrumentationArgs);
            }
            catch (Exception e) {
                throw new RuntimeException(
                    "Exception thrown in onCreate() of "
                    + data.instrumentationName + ": " + e.toString(), e);
            }

            try {
            	//调用Application.onCreate()回调方法
                mInstrumentation.callApplicationOnCreate(app);
            } catch (Exception e) {
                if (!mInstrumentation.onException(app, e)) {
                    throw new RuntimeException(
                        "Unable to create application " + app.getClass().getName()
                        + ": " + e.toString(), e);
                }
            }
        } finally {
            StrictMode.setThreadPolicy(savedPolicy);
        }
    }
```

这个方法很长，工作内容如下：

1. 对进程基本参数的设置，比如进程名，时区，资源及兼容性设置；同时添加了对开发者的限制，如不能在主线程使用网络
2. 通过getPackageInfoNoCheck获取LoadedApk对象
3. 实例化ContextImpl，Instrumentation等对象
4. 通过LoadedApk.makeApplication创建应用Application对象
5. 调用Instrumentation.callApplicationOnCreate



#####获取LoadedApk对象

这里返回一个LoadedApk对象，这个对象有什么作用呢？
**注意**：LoadedApk对象是APK文件在内存中的表示，包含apk文件的相关信息，比如应用代码，资源文件，app里的activity和service等都可以从这获取，在使用类加载器的时候需要用到这个对象

```java
public final LoadedApk getPackageInfoNoCheck(ApplicationInfo ai,
            CompatibilityInfo compatInfo) {
        return getPackageInfo(ai, compatInfo, null, false, true, false);
    }

private LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,
            ClassLoader baseLoader, boolean securityViolation, boolean includeCode,
            boolean registerPackage) {
         //判断调用方和应用程序是不是同一个用户，如果不是，就不允许跨用户访问
        final boolean differentUser = (UserHandle.myUserId() != UserHandle.getUserId(aInfo.uid));
        synchronized (mResourcesManager) {
            WeakReference<LoadedApk> ref;
            if (differentUser) {
                // 不支持跨用户访问缓存
                ref = null;
            } else if (includeCode) {
            	//进入到这个分支，根据应用包名从mPackages获取，也就是说每个app都会拥有唯一的LoadedApk对象
                ref = mPackages.get(aInfo.packageName);
            } else {
                ref = mResourcePackages.get(aInfo.packageName);
            }

            LoadedApk packageInfo = ref != null ? ref.get() : null;
            //刚进来这个为null
            if (packageInfo == null || (packageInfo.mResources != null
                    && !packageInfo.mResources.getAssets().isUpToDate())) {

				//创建LoadedApk对象
                packageInfo = new LoadedApk(this, aInfo, compatInfo, baseLoader,
                            		securityViolation, includeCode &&
                            			(aInfo.flags&ApplicationInfo.FLAG_HAS_CODE) != 0, registerPackage);

                if (mSystemThread && "android".equals(aInfo.packageName)) {
                    packageInfo.installSystemApplicationInfo(aInfo,
                            getSystemContext().mPackageInfo.getClassLoader());
                }

                if (differentUser) {
                    // Caching not supported across users
                } else if (includeCode) {
                	//将新创建的LoadedApk加入到mPackages
                    mPackages.put(aInfo.packageName,
                            new WeakReference<LoadedApk>(packageInfo));
                } else {
                    mResourcePackages.put(aInfo.packageName,
                            new WeakReference<LoadedApk>(packageInfo));
                }
            }
            return packageInfo;
        }
    }

```

##### LoadedApk.makeApplication

```java
public Application makeApplication(boolean forceDefaultAppClass,
            Instrumentation instrumentation) {
        if (mApplication != null) {
            return mApplication;
        }

        Application app = null;

        String appClass = mApplicationInfo.className;
        if (forceDefaultAppClass || (appClass == null)) {
            appClass = "android.app.Application";
        }

        try {
        	//类加载器
            java.lang.ClassLoader cl = getClassLoader();
            if (!mPackageName.equals("android")) {
                initializeJavaContextClassLoader();
            }
            //创建ContextImpl，在组件中对Context的操作都会转移到这个类
            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);
            //创建Application
            app = mActivityThread.mInstrumentation.newApplication(
                    cl, appClass, appContext);
            appContext.setOuterContext(app);
        } catch (Exception e) {
            if (!mActivityThread.mInstrumentation.onException(app, e)) {
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                throw new RuntimeException(
                    "Unable to instantiate application " + appClass
                    + ": " + e.toString(), e);
            }
        }
        mActivityThread.mAllApplications.add(app);
        //给mApplication赋值
        mApplication = app;

        ......
        
        SparseArray<String> packageIdentifiers = getAssets(mActivityThread)
            .getAssignedPackageIdentifiers();
    		final int N = packageIdentifiers.size();
    		for (int i = 0; i < N; i++) {
	        final int id = packageIdentifiers.keyAt(i);
	        if (id == 0x01 || id == 0x7f) {
	            continue;
        	}
        	//重写所有apk库中的R常量
        	rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id);
    	  }

        return app;
    }

```



##### **Instrumentation.newApplication**

```java
public Application newApplication(ClassLoader cl, String className, Context context)
            throws InstantiationException, IllegalAccessException, 
            ClassNotFoundException {
        return newApplication(cl.loadClass(className), context);
    }
static public Application newApplication(Class<?> clazz, Context context)
            throws InstantiationException, IllegalAccessException, 
            ClassNotFoundException {
            // 这里通过反射实例化Application ，然后调用attach
        Application app = (Application)clazz.newInstance();
        app.attach(context);
        return app;
    }
```

```java
// Application 类
final void attach(Context context) {
		//给ContextWrapper对象中指定真正的Context（这里的Context实际类型是ContextImpl ）对象
        attachBaseContext(context);
  			// 注意这里的Context类型！！是真实实现：ContextImpl
        mLoadedApk = ContextImpl.getImpl(context).mPackageInfo;
    }

// ContextWrapper类
protected void attachBaseContext(Context base) {
        if (mBase != null) {
            throw new IllegalStateException("Base context already set");
        }
  			// 这里对mBase 进行赋值，实际类型是ContextImpl
        mBase = base;
    }

```



##### onCreate

```java
// Instrumentation类
public void callApplicationOnCreate(Application app) {
        app.onCreate();
    }
```

```java
// Application类！！
/**
     * 在应用启动时调用 ，在创建任何activity, service,receiver，content providers之前调用
     * 在此方法里操作要尽可能快（比如状态的延迟初始化），因为在这里花费太长时间将会直接影响第一个
     * activity, service,receiver，content providers的性能
     * 如果重写这个方法，请务必调用super.onCreate（）
     */
    @CallSuper
    public void onCreate() {
    }

```

这里就会回调Application的onCreate方法，我们通常会继承这个类，重写这个方法，做一些APP的初始化操作，但是切记不要做耗时复杂操作，因为这里应用才刚创建，还在初始化，可能会导致应用启动黑屏一段时间的情况

AMS.attachApplicationLocked方法执行完bindApplication后，对照着顶部目录看，接下来就是该方法第七步，启动Activity等操作了


### 14、attachApplicationLocked



```java
// ActivityStackSupervisor 类
boolean attachApplicationLocked(ProcessRecord app) throws RemoteException {
        final String processName = app.processName;
        boolean didSomething = false;
        //这里维护着这台设备上所有应用的activitystack，即app的任务栈
        for (int displayNdx = mActivityDisplays.size() - 1; displayNdx >= 0; --displayNdx) {
        	//取出其中一个任务栈
            ArrayList<ActivityStack> stacks = mActivityDisplays.valueAt(displayNdx).mStacks;
            for (int stackNdx = stacks.size() - 1; stackNdx >= 0; --stackNdx) {
                final ActivityStack stack = stacks.get(stackNdx);
                if (!isFocusedStack(stack)) {
                    continue;
                }
                //取出当前任务栈中处于栈顶且运行的activity
                ActivityRecord hr = stack.topRunningActivityLocked();
                if (hr != null) {
                	//判断这个activity所在进程是否与当前调用的进程信息是否一致
                    if (hr.app == null && app.uid == hr.info.applicationInfo.uid
                            && processName.equals(hr.processName)) {
                        try {
                        	//真正启动activity
                            if (realStartActivityLocked(hr, app, true, true)) {
                                didSomething = true;
                            }
                        } catch (RemoteException e) {
                            throw e;
                        }
                    }
                }
            }
        }
        if (!didSomething) {
        		//启动失败，需要确保一个可显示的activity
            ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);
        }
        return didSomething;
    }

final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app,
            boolean andResume, boolean checkConfig) throws RemoteException {
				
				//如果activity正在pausing，那就跳过
        if (!allPausedActivitiesComplete()) {
            return false;
        }

        if (andResume) {
            r.startFreezingScreenLocked(app, 0);
            mWindowManager.setAppVisibility(r.appToken, true);
            // 启动ticks以收集有关慢速APP的信息。
            r.startLaunchTickingLocked();
        }

        // 让window manager根据新的activity顺序重新评估屏幕方向
        if (checkConfig) {
            Configuration config = mWindowManager.updateOrientationFromAppTokens(
                    mService.mConfiguration,
                    r.mayFreezeScreenLocked(app) ? r.appToken : null);
            mService.updateConfigurationLocked(config, r, false);
        }

				......

        final ActivityStack stack = task.stack;
        try {
            ......
            
            //将该进程设置为前台进程PROCESS_STATE_TOP
            app.forceProcessStateUpTo(mService.mTopProcessState);
            //启动activity
            app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,
                    System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration),
                    new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage,
                    task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,
                    newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);

            if ((app.info.privateFlags&ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0) {
                // 处理heavy-weight process
                if (app.processName.equals(app.info.packageName)) {
                    if (mService.mHeavyWeightProcess != null
                            && mService.mHeavyWeightProcess != app) {
                        Slog.w(TAG, "Starting new heavy weight process " + app
                                + " when already running "
                                + mService.mHeavyWeightProcess);
                    }
                    mService.mHeavyWeightProcess = app;
                    Message msg = mService.mHandler.obtainMessage(
                            ActivityManagerService.POST_HEAVY_NOTIFICATION_MSG);
                    msg.obj = r;
                    mService.mHandler.sendMessage(msg);
                }
            }

        } catch (RemoteException e) {
            if (r.launchFailed) {
                // 第二次启动失败就放弃 并finish该activity
                mService.appDiedLocked(app);
                stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null,
                        "2nd-crash", false);
                return false;
            }

            // 第一次启动失败就重启该进程
            app.activities.remove(r);
            throw e;
        }

        r.launchFailed = false;
        //将该进程加入到mLRUActivities队列顶部
        if (stack.updateLRUListLocked(r)) {
        }

				......

        //更新所有与该Activity具有绑定关系的Service连接
        if (r.app != null) {
            mService.mServices.updateServiceConnectionActivitiesLocked(r.app);
        }

        return true;
    }

```

这个方法里这最重要的一步就是app.thread.scheduleLaunchActivity，这里又是一个AIDL实现，app.thread的实际类型是客户端进程在AMS端进程的代理，即ATP；接下来具体过程跟上面分析thread.scheduleExit()的时候一样，这里就不在具体阐述了，直接到ActivityThread

```java
private class H extends Handler {
			public void handleMessage(Message msg) {
            switch (msg.what) {
            case LAUNCH_ACTIVITY: {
                    final ActivityClientRecord r = (ActivityClientRecord) msg.obj;
                    //获取LoadedApk对象
                    r.packageInfo = getPackageInfoNoCheck(
                            r.activityInfo.applicationInfo, r.compatInfo);
                    handleLaunchActivity(r, null, "LAUNCH_ACTIVITY");
                } break;
            }
      }
}

private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {

        unscheduleGcIdler();
        mSomeActivitiesChanged = true;

        if (r.profilerInfo != null) {
            mProfiler.setProfiler(r.profilerInfo);
            mProfiler.startProfiling();
        }

        //最终回调目标Activity的onConfigurationChanged()
        handleConfigurationChanged(null, null);

        // 在创建activity之前初始化wms
        WindowManagerGlobal.initialize();
				//最终回调目标Activity的onCreate
        Activity a = performLaunchActivity(r, customIntent);

        if (a != null) {
            r.createdConfig = new Configuration(mConfiguration);
            reportSizeConfigurations(r);
            Bundle oldState = r.state;
            //最终回调目标Activity的onStart,onResume
            handleResumeActivity(r.token, false, r.isForward,
                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);
        } else {
            // 如果失败或者其它原因就通知 activity manager 去stop activity.
            try {
                ActivityManagerNative.getDefault()
                    .finishActivity(r.token, Activity.RESULT_CANCELED, null,
                            Activity.DONT_FINISH_TASK_WITH_ACTIVITY);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
        }
    }

```



这里调用了两个关键方法

- performLaunchActivity
- handleResumeActivity



####AT.performLaunchActivity

```java
private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {

		//获取待启动的Activity的组件信息
        ActivityInfo aInfo = r.activityInfo;
        if (r.packageInfo == null) {
            r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,
                    Context.CONTEXT_INCLUDE_CODE);
        }
        ComponentName component = r.intent.getComponent();
        if (component == null) {
            component = r.intent.resolveActivity(
                mInitialApplication.getPackageManager());
            r.intent.setComponent(component);
        }
        if (r.activityInfo.targetActivity != null) {
            component = new ComponentName(r.activityInfo.packageName,
                    r.activityInfo.targetActivity);
        }

        Activity activity = null;
        try {
        	//通过类加载器加载activity实例
            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
            activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
            StrictMode.incrementExpectedActivityCount(activity.getClass());
            r.intent.setExtrasClassLoader(cl);
            r.intent.prepareToEnterProcess();
            if (r.state != null) {
                r.state.setClassLoader(cl);
            }
        } catch (Exception e) {
            if (!mInstrumentation.onException(activity, e)) {
                throw new RuntimeException(
                    "Unable to instantiate activity " + component
                    + ": " + e.toString(), e);
            }
        }

        try {
            Application app = r.packageInfo.makeApplication(false, mInstrumentation);

            if (activity != null) {
            	//创建该activity的context实例，实际类型是ContextImpl
                Context appContext = createBaseContextForActivity(r, activity);
                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());
                Configuration config = new Configuration(mCompatConfiguration);
                if (r.overrideConfig != null) {
                    config.updateFrom(r.overrideConfig);
                }
                
                Window window = null;
                if (r.mPendingRemoveWindow != null && r.mPreserveWindow) {
                    window = r.mPendingRemoveWindow;
                    r.mPendingRemoveWindow = null;
                    r.mPendingRemoveWindowManager = null;
                }
                //在这个方法里关联context，并进行Activity一些初始化操作,
                //比如完成Window的创建并建立自己和Window的关联
                //这样当Window接收到外部输入事件后就可以将事件传递给Activity；
                //维护一个Instrumentation引用
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window);

                if (customIntent != null) {
                    activity.mIntent = customIntent;
                }
                r.lastNonConfigurationInstances = null;
                activity.mStartedActivity = false;
                //获取主题并设置
                int theme = r.activityInfo.getThemeResource();
                if (theme != 0) {
                    activity.setTheme(theme);
                }

				//回调activity的onCreate
                activity.mCalled = false;
                if (r.isPersistable()) {
                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
                } else {
                    mInstrumentation.callActivityOnCreate(activity, r.state);
                }
                if (!activity.mCalled) {
                    throw new SuperNotCalledException(
                        "Activity " + r.intent.getComponent().toShortString() +
                        " did not call through to super.onCreate()");
                }
                r.activity = activity;
                r.stopped = true;
                if (!r.activity.mFinished) {
                    activity.performStart();
                    r.stopped = false;
                }
                if (!r.activity.mFinished) {
                		//如果之前有保存数据，这里回调OnRestoreInstance
                    if (r.isPersistable()) {
                        if (r.state != null || r.persistentState != null) {
                            mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,
                                    r.persistentState);
                        }
                    } else if (r.state != null) {
                        mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);
                    }
                }
                
            }
            r.paused = true;

            mActivities.put(r.token, r);

        } catch (SuperNotCalledException e) {
            throw e;

        } catch (Exception e) {
            if (!mInstrumentation.onException(activity, e)) {
                throw new RuntimeException(
                    "Unable to start activity " + component
                    + ": " + e.toString(), e);
            }
        }

        return activity;
    }
```



####2、AT.handleResumeActivity

```java
final void handleResumeActivity(IBinder token,
            boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) {
        ActivityClientRecord r = mActivities.get(token);
        
        ......
        //见下方
        r = performResumeActivity(token, clearHide, reason);

        if (r != null) {
            final Activity a = r.activity;

            final int forwardBit = isForward ?
                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;

            // 如果当前窗口没有添加到 window manager,并且它没有finished或者启动其它activity
            // 那就继续添加到 window manager
            boolean willBeVisible = !a.mStartedActivity;
            if (!willBeVisible) {
                try {
                    willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible(
                            a.getActivityToken());
                } catch (RemoteException e) {
                    throw e.rethrowFromSystemServer();
                }
            }
            if (r.window == null && !a.mFinished && willBeVisible) {
                r.window = r.activity.getWindow();
                View decor = r.window.getDecorView();
                decor.setVisibility(View.INVISIBLE);
                ViewManager wm = a.getWindowManager();
                WindowManager.LayoutParams l = r.window.getAttributes();
                a.mDecor = decor;
                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
                l.softInputMode |= forwardBit;
                if (r.mPreserveWindow) {
                    a.mWindowAdded = true;
                    r.mPreserveWindow = false;
                    ViewRootImpl impl = decor.getViewRootImpl();
                    if (impl != null) {
                        impl.notifyChildRebuilt();
                    }
                }
                if (a.mVisibleFromClient && !a.mWindowAdded) {
                    a.mWindowAdded = true;
                    wm.addView(decor, l);
                }

            // 如果该窗口已经添加到了window manager，但是在resume期间，又启动了了一个activity
            //那就设置窗口不可见
            } else if (!willBeVisible) {
                r.hideForNow = true;
            }

            // Get rid of anything left hanging around.
            cleanUpPendingRemoveWindows(r, false /* force */);

            // 如果窗口已经添加，没有finish，没有启动其它activity，那窗口可见
            if (!r.activity.mFinished && willBeVisible
                    && r.activity.mDecor != null && !r.hideForNow) {
                if (r.newConfig != null) {
                    performConfigurationChangedForActivity(r, r.newConfig, REPORT_TO_ACTIVITY);
                    r.newConfig = null;
                }
               
               //设置输入框显示模式
                WindowManager.LayoutParams l = r.window.getAttributes();
                if ((l.softInputMode
                        & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)
                        != forwardBit) {
                    l.softInputMode = (l.softInputMode
                            & (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))
                            | forwardBit;
                    if (r.activity.mVisibleFromClient) {
                        ViewManager wm = a.getWindowManager();
                        View decor = r.window.getDecorView();
                        wm.updateViewLayout(decor, l);
                    }
                }
                r.activity.mVisibleFromServer = true;
                mNumVisibleActivities++;
                //将当前activity视图设置可见
                if (r.activity.mVisibleFromClient) {
                    r.activity.makeVisible();
                }
            }

            // 告诉 activity manager 该activity已经 resumed.
            if (reallyResume) {
                try {
                    ActivityManagerNative.getDefault().activityResumed(token);
                } catch (RemoteException ex) {
                    throw ex.rethrowFromSystemServer();
                }
            }

        } else {
            // 当 resume 失败, 就结束这个activity
            try {
                ActivityManagerNative.getDefault()
                    .finishActivity(token, Activity.RESULT_CANCELED, null,
                            Activity.DONT_FINISH_TASK_WITH_ACTIVITY);
            } catch (RemoteException ex) {
                throw ex.rethrowFromSystemServer();
            }
        }
    }

```



AT.performResumeActivity



```java
public final ActivityClientRecord performResumeActivity(IBinder token,
            boolean clearHide, String reason) {
        ActivityClientRecord r = mActivities.get(token);
        
        if (r != null && !r.activity.mFinished) {
            if (clearHide) {
                r.hideForNow = false;
                r.activity.mStartedActivity = false;
            }
            try {
                r.activity.onStateNotSaved();
                r.activity.mFragments.noteStateNotSaved();
                if (r.pendingIntents != null) {
                	//回调onNewIntent
                    deliverNewIntents(r, r.pendingIntents);
                    r.pendingIntents = null;
                }
                if (r.pendingResults != null) {
                	//回调onActivityResult
                    deliverResults(r, r.pendingResults);
                    r.pendingResults = null;
                }
                //在这里相继回调onStart onResume
                r.activity.performResume();
				......

                r.paused = false;
                r.stopped = false;
                r.state = null;
                r.persistentState = null;
            } catch (Exception e) {
                if (!mInstrumentation.onException(r.activity, e)) {
                    throw new RuntimeException(
                        "Unable to resume activity "
                        + r.intent.getComponent().toShortString()
                        + ": " + e.toString(), e);
                }
            }
        }
        return r;
    }

```

到这里一个Activity就从无到有被启动且可见了



## Window创建过程

熟悉了Activity的启动流程，Window的创建流程其实都在里面了，下面集中分析下相关源码（源码分析来自：https://blog.csdn.net/qq_36486247/article/details/100694062）

###2.1.Window的创建
Window的创建时机是在ActivityThread的performLaunchActivity()方法中，在之前Activity的启动流程中也分析过该方法，我们再来简单回顾一下：
ActivityThread的performLaunchActivity方法

```java
private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
    // ... 
    java.lang.ClassLoader cl = appContext.getClassLoader();
    // 1.创建Activity对象
    activity = mInstrumentation.newActivity(
            cl, component.getClassName(), r.intent);
    // ...
  
    // 2.创建Application对象，如果已经创建则不会重复创建
    Application app = r.packageInfo.makeApplication(false, mInstrumentation);
    // ...
  
    if (activity != null) {
        // ...
        Window window = null;
        if (r.mPendingRemoveWindow != null && r.mPreserveWindow) {
            window = r.mPendingRemoveWindow;
            r.mPendingRemoveWindow = null;
            r.mPendingRemoveWindowManager = null;
        }
        appContext.setOuterContext(activity);
      	// 3.创建PhoneWindow
        activity.attach(appContext, this, getInstrumentation(), r.token,
                r.ident, app, r.intent, r.activityInfo, title, r.parent,
                r.embeddedID, r.lastNonConfigurationInstances, config,
                r.referrer, r.voiceInteractor, window, r.configCallback);

        // ...
      	// 4.调用onCreate()方法
        if (r.isPersistable()) {
            mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
        } else {
            mInstrumentation.callActivityOnCreate(activity, r.state);
        }
        // ...
        r.activity = activity;
    }
    // ...
    return activity;
}

```

该方法内部会依次创建Activity对象和Application对象，最后通过Instrumentation对象调用Activity的`onCreate()`方法，这些都不是我们这里要关注的，我们只需要分析Activity的`attach()`方法。

#### **Activity的attach方法**

```java
final void attach(Context context, ActivityThread aThread,
                  Instrumentation instr, IBinder token, int ident,
                  Application application, Intent intent, ActivityInfo info,
                  CharSequence title, Activity parent, String id,
                  NonConfigurationInstances lastNonConfigurationInstances,
                  Configuration config, String referrer, IVoiceInteractor voiceInteractor,
                  Window window, ActivityConfigCallback activityConfigCallback) {
    // ...

    // 创建PhoneWindow
    mWindow = new PhoneWindow(this, window, activityConfigCallback);
  	// 设置回调
  	mWindow.setWindowControllerCallback(this);
    mWindow.setCallback(this);
    mWindow.setOnWindowDismissedCallback(this);

    // ...
	
  	// 设置WindowManager
    mWindow.setWindowManager(
            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),
            mToken, mComponent.flattenToString(),
            (info.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);
    if (mParent != null) {
        mWindow.setContainer(mParent.getWindow());
    }
    mWindowManager = mWindow.getWindowManager();
    // ...
}
```

可以发现PhoneWindow对象就是在`attach()`方法中创建的，之后会为PhoneWindow设置相关回调并创建WindowManager对象（实际上是WindowManagerImpl对象）。

### 2.2.DecorView的创建

在Activity的`onCreate()`方法中我们会调用`setContentView()`来设置页面的布局，DecorView的创建就要从该方法来分析。
**Activity的setContentView方法**

```java
public void setContentView(@LayoutRes int layoutResID) {
    getWindow().setContentView(layoutResID);
    initWindowDecorActionBar();
}
```



`getWindow()`方法获取到的就是上面创建好的PhoneWindow对象，我们接着来看PhoneWindow的`setContentView()`方法：
**PhoneWindow的setContentView方法**

```java
@Override
public void setContentView(int layoutResID) {
    if (mContentParent == null) {
        installDecor();
    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        mContentParent.removeAllViews();
    }

    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,
                getContext());
        transitionTo(newScene);
    } else {
        mLayoutInflater.inflate(layoutResID, mContentParent);
    }
    mContentParent.requestApplyInsets();
    final Callback cb = getCallback();
    if (cb != null && !isDestroyed()) {
        cb.onContentChanged();
    }
    mContentParentExplicitlySet = true;
}

```

我们来看看`installDecor()`方法：

```java
private void installDecor() {
    mForceDecorInstall = false;
    if (mDecor == null) {
        mDecor = generateDecor(-1);
        // ...
    } else {
        mDecor.setWindow(this);
    }
    if (mContentParent == null) {
        mContentParent = generateLayout(mDecor);
        // ...
    }
}

protected DecorView generateDecor(int featureId) {
    Context context;
    if (mUseDecorContext) {
        Context applicationContext = getContext().getApplicationContext();
        if (applicationContext == null) {
            context = getContext();
        } else {
            context = new DecorContext(applicationContext, getContext());
            if (mTheme != -1) {
                context.setTheme(mTheme);
            }
        }
    } else {
        context = getContext();
    }
    return new DecorView(context, featureId, this, getAttributes());
}

protected ViewGroup generateLayout(DecorView decor) {
    TypedArray a = getWindowStyle();
    // ...
    int layoutResource;
    // 根据Features（通过requestFeature()方法添加，可以看做是Window的主题样式）设置相应的布局
    // 伪代码
    if () {
        layoutResource =R.layout.xx1;
    } else if () {
        layoutResource =R.layout.xx2;
    } else {
        layoutResource =R.layout.xx;
    }
	// 为DecorView加载布局
    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);

    ViewGroup contentParent = (ViewGroup) findViewById(ID_ANDROID_CONTENT);
    // ...
    return contentParent;
}

```

可以看到installDecor()方法主要做的事有两件：

* 调用generateDecor()方法创建DecorView，将返回值赋给mDecor；
* 调用generateLayout()方法创建一个ViewGroup，赋值给mContentParent。

这里的generateDecor()和generateLayout()方法都省略了大量代码，只保留了最核心的部分。
创建好了DecorView和mContentParent之后，我们回到PhoneWindow的setContentView()方法，可以发现这之后调用了mLayoutInflater.inflate(layoutResID, mContentParent)，inflate()方法的作用我们都很熟悉了，就是根据我们传入的布局文件构建出View树，这里调用的是两个参数的方法，因此会将创建好的View树添加到mContentParent中。如果不是很清楚inflate()方法几个参数的意义可以查阅网上的相关文章，或者参考我之前写过的一篇文章LayoutInflate的使用，这里我就不具体讲了。现在我们就清楚了mContentParent是什么了吧，它是我们setContentView()方法中指定布局的父View，指定的布局会作为一个子View添加到mContentParent中。



###2.3 traversal触发
上面的两个流程中已经完成了PhoneWindow和DecorView的创建，那么大名鼎鼎的View绘制三大流程又是从何时开始的呢，就是ActivityThread的handleResumeActivity() 方法，该方法在分析Activity的启动流程时也分析过，onResume()回调方法就是经由该方法调用的。

####handleResumeActivity

**ActivityThread的handleResumeActivity方法**

```java
@Override
public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,
                                 String reason) {
    // ...
    // 方法内部调用Activity的onResume()方法
    final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);
    // ...
    final Activity a = r.activity;
    // ...
    if (r.window == null && !a.mFinished && willBeVisible) {
        r.window = r.activity.getWindow();
        // 获取DecorView
        View decor = r.window.getDecorView();
        // 将DecorView设置为不可见
        decor.setVisibility(View.INVISIBLE);
        // 获取WindowManager
        ViewManager wm = a.getWindowManager();
        WindowManager.LayoutParams l = r.window.getAttributes();
        // 为Activity的mDecor对象赋值
        a.mDecor = decor;
        // ...
        if (a.mVisibleFromClient) {
            if (!a.mWindowAdded) {
                a.mWindowAdded = true;
                // 将DecorView添加到Window中
                wm.addView(decor, l);
            } else {
                a.onWindowAttributesChanged(l);
            }
        }
    }
    // ...
    if (!r.activity.mFinished && willBeVisible && r.activity.mDecor != null && !r.hideForNow) {
        // ...
        if (r.activity.mVisibleFromClient) {
            // 将DecorView设置为可见
            r.activity.makeVisible();
        }
    }
}
```

该方法主要做了两件事：调用performResumeActivity()方法，进而调用Activity的生命周期回调onResume()；获取此前创建好的PhoneWindow、DecorView以及WindowManager对象，调用WindowManager的addView()方法将DecorView添加到Window中。前面也说过，WindowManager的实现类是WindowManagerImpl，因此我们来具体看一下WindowManagerImpl的addView()方法都做了些什么。
WindowManagerImpl的addView方法

```java
@Override
public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
    applyDefaultToken(params);
    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);
}

```



方法内部调用了mGlobal的`addView()`方法，mGlobal的类型为WindowManagerGlobal，

####WindowManagerGlobal

WindowManagerGlobal 在整个应用进程中是以单例存在的，也就是说在整个应用进程中，所有的 Window 和 WindowManagerImpl 对象都对应着这个 WindowManagerGlobal 对象，

其源码如下，在其中有几个变量非常重要

- `ArrayList mViews`：存储所有 Window 所对应的 View
- `ArrayList`：存储所有 Window 所对应的 ViewRootImpl
- `ArrayList`：存储所有 Window 所对应的 WindowManager.LayoutParams
- `ArraySet`：存储所有即将被移除的 View

```java
public final class WindowManagerGlobal {
    
    // WindowManagerGlobal 单例对象 
    private static WindowManagerGlobal sDefaultWindowManager;
    // IWindowManager & IWindowSession 用于和 WindowManagerService 通过 Binder 通信
    private static IWindowManager sWindowManagerService;
    private static IWindowSession sWindowSession;

    private final Object mLock = new Object();

    private final ArrayList<View> mViews = new ArrayList<View>();
    private final ArrayList<ViewRootImpl> mRoots = new ArrayList<ViewRootImpl>();
    private final ArrayList<WindowManager.LayoutParams> mParams =
        new ArrayList<WindowManager.LayoutParams>();
    private final ArraySet<View> mDyingViews = new ArraySet<View>();
    
   // 私有构造方法
    private WindowManagerGlobal() {
    }

   // 初始化方法
    public static void initialize() {
        getWindowManagerService();
    }

    public static WindowManagerGlobal getInstance() {
        synchronized (WindowManagerGlobal.class) {
            if (sDefaultWindowManager == null) {
                sDefaultWindowManager = new WindowManagerGlobal();
            }
            return sDefaultWindowManager;
        }
    }

   // 创建 IWindowManager 对象
    public static IWindowManager getWindowManagerService() {
        synchronized (WindowManagerGlobal.class) {
            if (sWindowManagerService == null) {
                sWindowManagerService = IWindowManager.Stub.asInterface(
                    ServiceManager.getService("window"));
                try {
                    if (sWindowManagerService != null) {
                        ValueAnimator.setDurationScale(
                            sWindowManagerService.getCurrentAnimatorScale());
                    }
                } catch (RemoteException e) {
                    throw e.rethrowFromSystemServer();
                }
            }
            return sWindowManagerService;
        }
    }

    // 非常重要的方法，向 Window 中添加 View，在这里 Window 和 View 产生了关联
    public void addView(View view, ViewGroup.LayoutParams params,
        Display display, Window parentWindow) {
        // ......
    }

    // 更新 Window 中的 View
    public void updateViewLayout(View view, ViewGroup.LayoutParams params) {
        // ......
    }

    // 从 Window 中移除 View
    public void removeView(View view, boolean immediate) {
        // ......
    }
}
```

####addView

我们接着看：**WindowManagerGlobal的addView方法**

```java
public void addView(View view, ViewGroup.LayoutParams params,
                    Display display, Window parentWindow) {
    // ...
    ViewRootImpl root;
    // ...
    // 创建ViewRootImpl对象
    root = new ViewRootImpl(view.getContext(), display);
  
    view.setLayoutParams(wparams);

    mViews.add(view);
    mRoots.add(root);
    mParams.add(wparams);

    try {
      	// 核心代码
        root.setView(view, wparams, panelParentView);
    } catch (RuntimeException e) {
        // BadTokenException or InvalidDisplayException, clean up.
        if (index >= 0) {
            removeViewLocked(index, true);
        }
        throw e;
    }
}
```



addView()方法内部首先会创建出ViewRootImpl对象，将要添加的View（即DecorView）、ViewRootImpl和布局参数添加到列表中，最后调用ViewRootImpl的setView()方法，我们来看一下这个方法。

####setView

ViewRootImpl的setView方法

```java
public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
    synchronized (this) {
        if (mView == null) {
            mView = view;
            // ...
            requestLayout();
            // ...
        }
    }
}

```



setView()方法内部调用了requestLayout()方法，这个方法可能大家在自定义View时用到过，用于刷新视图，不过需要注意的是，我们在自定义View中调用的requestLayout()方法是在View中定义的，和ViewRootImpl中的逻辑是不一样的。

接下来我们就来看看ViewRootImpl的requestLayout()方法：

```java
// ViewRootImpl类
@Override
public void requestLayout() {
    if (!mHandlingLayoutInLayoutRequest) {
        checkThread();
        mLayoutRequested = true;
        scheduleTraversals();
    }
}

void scheduleTraversals() {
    if (!mTraversalScheduled) {
        mTraversalScheduled = true;
      	// 开启同步屏障机制
        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
      	// 利用Handler发送一条异步消息
        mChoreographer.postCallback(
                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
        // ...
    }
}

```

`scheduleTraversals()`方法内部首先执行了`mHandler.getLooper().getQueue().postSyncBarrier()`，这行代码的作用是开启Handler的同步屏障机制

关于Handler的同步屏障机制，我这里简单解释一下（因为我了解得也不是很透彻o(╥﹏╥)o），我们都知道Handler处理的消息是放到一个消息队列中的，消息默认情况下都是同步的，如果需要发送异步消息需要使用代码来声明，同步屏障机制就使得Looper在从消息队列中获取消息时，只获取异步消息并进行处理。我可能解释得不太好，如果想深入了解一下Handler的同步屏障机制可以自行查找资料，这里推荐一下鸿洋大神WanAndroid上的每日一问[Handler应该是大家再熟悉不过的类了，那么其中有个同步屏障机制，你了解多少呢？](https://www.wanandroid.com/wenda/show/8710)。开启了同步屏障后，调用了mChoreographer的postCallback()方法，该方法内部就是利用了Handler，发送了一个Runable对象，如果跟踪源码的话可以发现最后会把Runable封装为一个Message，并将Message设置为异步消息，我就不展示了。清楚了postCallback()方法的原理后，我们就知道了需要分析mTraversalRunnable对象，它是一个Runable对象，类型为TraversalRunnable ，在run()方法中调用了doTraversal()方法。


```java
// ViewRootImpl类
final class TraversalRunnable implements Runnable {
    @Override
    public void run() {
        doTraversal();
    }
}

void doTraversal() {
    if (mTraversalScheduled) {
        mTraversalScheduled = false;
      	// 关闭同步屏障
        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);
        // ...
        performTraversals();
        // ...
    }
}

private void performTraversals() {
    // ...
    // 调用performMeasure()方法开始measure流程
    measureHierarchy(host, lp, res,
            desiredWindowWidth, desiredWindowHeight);
    // ...
    // 开始layout流程
    performLayout(lp, mWidth, mHeight);
    // ...
    // 开始draw流程
    performDraw();
    // ...
}

```



这里省略了大量代码，可以看出，在performTraversals()方法内会依次调用measureHierarchy() 、performLayout()、performDraw()，进而开始View的三大流程。
分析到这里，View的绘制准备阶段就算完成了，最后再回顾一下，主要分为三个阶段：

* Activity的onCreate()方法调用之前，创建Window（PhoneWindow）
* Activity的onCreate()方法中调用setContentView()方法，创建DecorView和contentView（页面内容根布局），将指定的布局文件加载到contentView中
* Activity的onResume()方法调用之后，将DecorView添加到Window中，之后依次开始View的measure、layout和draw流程



从上面几个流程的先后顺序我们就能清楚为什么在onResume()方法中或者onResume()方法之前获取不到View的宽高，就是因为此时View还未执行measure和layout流程。



##Window与WMS之间的双向通信

`ViewRootImpl`用于管理窗口的根`View`，并和`WMS`进行交互，是客户端与WMS进行IPC通信的桥梁

![img](https://upload-images.jianshu.io/upload_images/4179925-b50b92e0810addbd.png)

```java
public final class ViewRootImpl implements ViewParent,
        View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks {
    ......
    final IWindowSession mWindowSession;
    final W mWindow;
    ......

    public ViewRootImpl(Context context, Display display) {
        mContext = context;
        // 代码 1，通过 WindowManagerGlobal.getWindowSession() 方法得到一个 IWindowSession 对象
        mWindowSession = WindowManagerGlobal.getWindowSession();   
        ......
        // 代码 2，通过 W 构造方法直接创建一个新的 W 对象
        mWindow = new W(this);                                     
        ......
    }

    ......
}
```



### 2.1 IWindowSession

IWindowSession 是一个 AIDL 接口，其服务端进程是 WMS，客户端进程是应用进程，IWindowSession 的创建是在 WindowManagerGlobal 中，如下所示：

```java
 public final class WindowManagerGlobal {
        private static IWindowManager sWindowManagerService;
        private static IWindowSession sWindowSession;
        ......
        public static IWindowManager getWindowManagerService() {
            synchronized (WindowManagerGlobal.class) {
                if (sWindowManagerService == null) {
                    sWindowManagerService = IWindowManager.Stub.asInterface(
                            ServiceManager.getService("window"));
                    try {
                        if (sWindowManagerService != null) {
                            ValueAnimator.setDurationScale(
                                    sWindowManagerService.getCurrentAnimatorScale());
                        }
                    } catch (RemoteException e) {
                        throw e.rethrowFromSystemServer();
                    }
                }
                return sWindowManagerService;
            }
        }

        public static IWindowSession getWindowSession() {
            synchronized (WindowManagerGlobal.class) {
                if (sWindowSession == null) {
                    try {
                        InputMethodManager imm = InputMethodManager.getInstance();
                        IWindowManager windowManager = getWindowManagerService();
                        sWindowSession = windowManager.openSession(
                                new IWindowSessionCallback.Stub() {
                                    @Override
                                    public void onAnimatorScaleChanged(float scale) {
                                        ValueAnimator.setDurationScale(scale);
                                    }
                                },
                                imm.getClient(), imm.getInputContext());
                    } catch (RemoteException e) {
                        throw e.rethrowFromSystemServer();
                    }
                }
                return sWindowSession;
            }
        }
        ......
    }
```

- 从 `getWindowSession()` 方法中我们可以看出，IWindowSession 对象的创建依赖于 IWindowManager 对象

- IWindowManager 也是一个 AIDL 接口，通过 getWindowManagerService()方法得到其对象，在getWindowManagerService()方法中，可以看到是典型的 Android 中 Binder 通信得到服务端在客户端进程中的代理对象的方式，远程端的对象即是 WMS，WMS 实现了 IWindowManager 接口

  ```java
  public class WindowManagerService extends IWindowManager.Stub
      implements Watchdog.Monitor,     WindowManagerPolicy.WindowManagerFuncs {
      ......
  }
  ```

- 在 getWindowSession()

   方法中，我们可以看到是调用了 IWindowManager 的 openSession方法，其实际的实现是在 WMS 中，WMS 中的 openSession方法如下所示

  ```java
  public class WindowManagerService extends IWindowManager.Stub
      implements Watchdog.Monitor,     WindowManagerPolicy.WindowManagerFuncs {
  
      @Override
      public IWindowSession openSession(IWindowSessionCallback callback, IInputMethodClient client,
          IInputContext inputContext) {
          if (client == null) throw new IllegalArgumentException("null client");
          if (inputContext == null) throw new IllegalArgumentException("null inputContext");
          Session session = new Session(this, callback, client, inputContext);
          return session;
      }
  }
  ```

> 可以看到，其实 ViewRootImpl 中的 IWindowSession 对象实际对应着 WMS 中的 Session 对象。

WindowManagerGlobal 和 WMS 实现的是单方向的通信，都是通过如下图所示的 Binder 方式进行进程间通信的



![img](https:////upload-images.jianshu.io/upload_images/4179925-03fe0559da3c5f01.png)



### 2.2 W 

W 类是 ViewRootImpl 的一个内部类，继承自`IWindow.Stub`，实现了 IWindow 接口，是一个`Binder`对象，用于接收`WMS`的各种消息， 如按键消息， 触摸消息等。



```java
public final class ViewRootImpl implements ViewParent,
        View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks {


    static class W extends IWindow.Stub {
        private final WeakReference<ViewRootImpl> mViewAncestor;
        private final IWindowSession mWindowSession;

        W(ViewRootImpl viewAncestor) {
            mViewAncestor = new WeakReference<ViewRootImpl>(viewAncestor);
            mWindowSession = viewAncestor.mWindowSession;
        }

        @Override
        public void resized(Rect frame, Rect overscanInsets, Rect contentInsets,
                Rect visibleInsets, Rect stableInsets, Rect outsets, boolean reportDraw,
                MergedConfiguration mergedConfiguration, Rect backDropFrame, boolean forceLayout,
                boolean alwaysConsumeNavBar, int displayId) {
            final ViewRootImpl viewAncestor = mViewAncestor.get();
            if (viewAncestor != null) {
                viewAncestor.dispatchResized(frame, overscanInsets, contentInsets,
                        visibleInsets, stableInsets, outsets, reportDraw, mergedConfiguration,
                        backDropFrame, forceLayout, alwaysConsumeNavBar, displayId);
            }
        }

        @Override
        public void moved(int newX, int newY) {
            final ViewRootImpl viewAncestor = mViewAncestor.get();
            if (viewAncestor != null) {
                viewAncestor.dispatchMoved(newX, newY);
            }
        }

        @Override
        public void dispatchAppVisibility(boolean visible) {
            final ViewRootImpl viewAncestor = mViewAncestor.get();
            if (viewAncestor != null) {
                viewAncestor.dispatchAppVisibility(visible);
            }
        }

        @Override
        public void dispatchGetNewSurface() {
            final ViewRootImpl viewAncestor = mViewAncestor.get();
            if (viewAncestor != null) {
                viewAncestor.dispatchGetNewSurface();
            }
        }

        @Override
        public void windowFocusChanged(boolean hasFocus, boolean inTouchMode) {
            final ViewRootImpl viewAncestor = mViewAncestor.get();
            if (viewAncestor != null) {
                viewAncestor.windowFocusChanged(hasFocus, inTouchMode);
            }
        }

        private static int checkCallingPermission(String permission) {
            try {
                return ActivityManager.getService().checkPermission(
                        permission, Binder.getCallingPid(), Binder.getCallingUid());
            } catch (RemoteException e) {
                return PackageManager.PERMISSION_DENIED;
            }
        }
        
        ......

    }
}
```

比如在 `ViewRootImpl#setView` 方法中，有如下代码，在代码 1 处通过 mWindowSession 调用 addToDisplay 方法时，会将 mWindow 传入，最后传给 WMS，这样 WMS 便得到了一个 W 对象的实例对象。

```java
public final class ViewRootImpl implements ViewParent,
        View.AttachInfo.Callbacks, ThreadedRenderer.DrawCallbacks {

    public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
        synchronized (this) {
            if (mView == null) {

                ......

                int res; /* = WindowManagerImpl.ADD_OKAY; */

                // Schedule the first layout -before- adding to the window
                // manager, to make sure we do the relayout before receiving
                // any other events from the system.
                requestLayout();
                if ((mWindowAttributes.inputFeatures
                        & WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {
                    mInputChannel = new InputChannel();
                }
                mForceDecorViewVisibility = (mWindowAttributes.privateFlags
                        & PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != 0;
                try {
                    mOrigWindowType = mWindowAttributes.type;
                    mAttachInfo.mRecomputeGlobalAttributes = true;
                    collectViewAttributes();
                    // 代码 1
                    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(),
                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                            mAttachInfo.mOutsets, mInputChannel);
                } catch (RemoteException e) {
                    mAdded = false;
                    mView = null;
                    mAttachInfo.mRootView = null;
                    mInputChannel = null;
                    mFallbackEventHandler.setView(null);
                    unscheduleTraversals();
                    setAccessibilityFocus(null, null);
                    throw new RuntimeException("Adding window failed", e);
                } finally {
                    if (restore) {
                        attrs.restore();
                    }
                }

                ......

            }
        }
    }
}

```

而在Session中，`addToDisplay`方法，确实调用WMS添加窗口：`mService.addWindow`

```java
public class Session extends IWindowSession.Stub
        implements IBinder.DeathRecipient {
  
@Override
public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,
        int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets,
        Rect outOutsets, InputChannel outInputChannel) {
    return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId,
            outContentInsets, outStableInsets, outOutsets, outInputChannel);
	}
}
```



从上面代码可以看到，在 ViewRootImpl 中不仅实现了从 ViewRootImpl 向 WMS 的通信，也实现了从 WMS 向 ViewRootImpl 的通信，如下图所示

![img](https:////upload-images.jianshu.io/upload_images/4179925-b50b92e0810addbd.png)



### 2.3 ViewRootHandler

`ViewRootHandler`，是`Handler`的子类， `W`会通过`Looper`把消息传递给`ViewRootHandler`。



##WMS控制窗口的显示

 **以下内容来自老罗的的博客，后面附有资料链接。**

`WMS`服务大致按照以下方式来控制哪些窗口需要显示的以及要显在哪里：

1. 每一个`Activity`窗口的大小都等于屏幕的大小，因此，只要对每一个`Activity`窗口设置一个不同的`Z`轴位置，然后就可以使得位于最上面的，即当前被激活的`Activity`窗口，才是可见的。
2. 每一个子窗口的Z轴位置都比它的父窗口大，但是大小要比父窗口小，这时候`Activity`窗口及其所弹出的子窗口都可以同时显示出来。
3. 对于非全屏`Activity`窗口来说，它会在屏幕的上方留出一块区域，用来显示状态栏。这块留出来的区域称对于屏幕来说，称为装饰区（`decoration`），而对于`Activity`窗口来说，称为内容边衬区（`Content Inset`）。
4. 输入法窗口只有在需要的时候才会出现，它同样是出现在屏幕的装饰区或者说`Activity`窗口的内容边衬区的。
5. 对于壁纸窗口，它出现需要壁纸的`Activity`窗口的下方，这时候要求`Activity`窗口是半透明的，这样就可以将它后面的壁纸窗口一同显示出来。
6. 两个`Activity`窗口在切换过程，实际上就是前一个窗口显示退出动画而后一个窗口显示开始动画的过程，而在动画的显示过程，窗口的大小会有一个变化的过程，这样就导致前后两个`Activity`窗口的大小不再都等于屏幕的大小，因而它们就有可能同时都处于可见的状态。事实上，`Activity`窗口的切换过程是相当复杂的，因为即将要显示的`Activity`窗口可能还会被设置一个启动窗口（`Starting Window`）。一个被设置了启动窗口的`Activity`窗口要等到它的启动窗口显示了之后才可以显示出来。



##APK程序运行过程

来自内核 framework概述

1. ActivityThread main()开始执行，调用prepareMainLooper，为UI线程创建一个消息队列
2. 然后创建一个ActivityThread对象，在其初始化代码中会创建：
   1. H（Handler）对象
   2. ApplicationThread(Binder)对象——负责接收远程AmS的IPC调用，接收到调用后，通过Handler把消息发送到消息队列 >> UI主线程会异步的从消息队列取出消息执行响应操作
3. 接着，UI主线程调用Looper.loop方法进入消息循环，不断读取、处理消息
4. 当ActivityThread收到远程AmS发送的start某个Activity的消息后，就会创建指定Activity，Activity又会创建PhoneWindow 》DecorView》相应的View/ViewGroup
5. 需要把创建好的界面显示到屏幕上：调用WindowManager创建ViewRoot对象+W对象 >> WindowManager再调用WmS远程接口添加窗口到屏幕上
6. 用户开始再屏幕上操作，
   1. KeyQ线程不断把用户消息存储到QueueEvent队列中
   2. InputDispatcher线程逐个取出消息，调用WmS处理该消息
   3. WmS判定窗口归属，调用窗口的W对象接口
   4. W是一个Binder负责接收WmS的IPC调用，并把消息传递给ViewRoot，ViewRoot再把消息传递给UI主线程ActivityThread
   5. ActivityThread解析消息并做处理
   6. 消息处理流：DecorView >> 内部子View > PhoneWindow > Activity



##点击App图标

具体过程：

1. 用户点击App图标，`Lanuacher`进程通过`Binder`联系到`System Server`进程发起`startActivity`。
2. `System Server`通过`Socket`联系到`Zygote`，`fork`出一个新的App进程。
3. 创建出一个新的App进程以后，`Zygote`启动App进程的`ActivityThread#main()`方法。
4. 在`ActivtiyThread`中，调用`AMS`进行`ApplicationThread`的绑定。
5. `AMS`发送创建`Application`的消息给`ApplicationThread`，进而转交给`ActivityThread`中的`H`，它是一个`Handler`，接着进行`Application`的创建工作。
6. `AMS`以同样的方式创建`Activity`，接着就是大家熟悉的创建`Activity`的工作了。